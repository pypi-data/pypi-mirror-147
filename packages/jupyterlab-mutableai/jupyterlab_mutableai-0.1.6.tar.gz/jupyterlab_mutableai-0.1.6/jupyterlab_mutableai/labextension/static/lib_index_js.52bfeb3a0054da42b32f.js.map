{"version":3,"file":"lib_index_js.52bfeb3a0054da42b32f.js","mappings":";;;;;;;;;;;;;;;;;;;AAAO;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACNP;AACA;AACA;AACoD;AACpD;AACA;AACA;AACO,kCAAkC,8DAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6CAA6C,4BAA4B,uBAAuB;AAChG;AACA;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;;;;AC7D3B;AACA;AACA;AACoD;AACZ;AACxC;AACA;AACA;AACO,8BAA8B,8DAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,oBAAoB,oDAAU;AAC9B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,gBAAgB,mEAAmE;AACnF,gBAAgB,sDAAsD;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;;;;;AClHoB;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kDAAkD;AACzD;AACA,qBAAqB,+EAA6B;AAClD,uBAAuB,8DAAW;AAClC;AACA;AACA;AACA,yBAAyB,8EAA4B;AACrD;AACA;AACA,kBAAkB,+EAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAA8B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;AClC8B;AACQ;AACtC,iEAAe,+CAAM,EAAC;;;;;;;;;;;;;;;;;;;;;;ACF0B;AACS;AACL;AACI;AACjD;AACP;AACA;AACA,0BAA0B,8DAAe;AACzC;AACA;AACA,sFAAsF,mEAAc;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uEAAqB;AAC1D;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,6BAA6B,iDAAU;AACvC,iBAAiB;AACjB;AACA,6BAA6B,qDAAc;AAC3C;AACA;AACA,6DAA6D,UAAU;AACvE;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnG8F;AAC/B;AACP;AACM;AACF;AACN;AACG;AACL;AACH;AACK;AACO;AACE;AACxB;AACU;AACoE;AACxE;AAC7C;AACA,QAAQ,8CAAS;AACjB;AACA,cAAc,+CAAU;AACxB;AACA,QAAQ,wEAAmB;AAC3B,QAAQ,yEAAgB;AACxB,QAAQ,2DAAS;AACjB,QAAQ,gEAAW;AACnB,QAAQ,kEAAgB;AACxB,QAAQ,qEAAkB;AAC1B;AACA;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA,4BAA4B,sDAAgB;AAC5C;AACA;AACA;AACA;AACA,6CAA6C,8CAAS;AACtD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,8CAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,iCAAiC;AACpG,qBAAqB;AACrB;AACA,2FAA2F,OAAO;AAClG,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA,gCAAgC,sDAAc;AAC9C;AACA;AACA,0CAA0C,QAAQ;AAClD,wCAAwC,8DAAc;AACtD,uCAAuC,gEAAc,GAAG,SAAS;AACjE;AACA,wCAAwC,mEAAY;AACpD;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,gCAAgC,mDAAW;AAC3C;AACA;AACA,sBAAsB,sEAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,kCAAkC,qDAAU;AAC5C;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kCAAkC;AAClC,sCAAsC,uEAAmB;AACzD;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,kEAAe;AACtD,wCAAwC,mEAAgB;AACxD;AACA;AACA;AACA;AACA;AACA,uCAAuC,yEAAe;AACtD,4CAA4C,uEAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,oCAAoC,sDAAc;AAClD;AACA;AACA;AACA;AACA,oDAAoD,8CAAM;AAC1D;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb;AACA,oCAAoC,sDAAc;AAClD;AACA;AACA;AACA,oDAAoD,8CAAM,IAAI,IAAI;AAClE;AACA;AACA,aAAa;AACb;AACA;AACA,yBAAyB,sDAAc;AACvC;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;ACrLoB;AAC1C;AACO,qBAAqB,KAAK;AAC1B,uBAAuB,oDAAK,IAAI,KAAK;;;;;;;;;;;;;;;;;;;ACHO;AACO;AACP;AACnD;AACA,YAAY,iBAAiB;AAC7B,oDAAoD,+CAAQ;AAC5D,gCAAgC,+CAAQ;AACxC,wDAAwD,+CAAQ;AAChE,kDAAkD,+CAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iEAAe;AACxC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAU;AACtB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY,gEAAU;AACtB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,YAAY,0DAAmB,UAAU,qCAAqC;AAC9E,QAAQ,0DAAmB;AAC3B,QAAQ,0DAAmB,UAAU,kCAAkC;AACvE,YAAY,0DAAmB,aAAa,2EAA2E;AACvH,QAAQ,0DAAmB,WAAW,wDAAwD;AAC9F,YAAY,0DAAmB,UAAU,kCAAkC;AAC3E,gBAAgB,0DAAmB;AACnC,gBAAgB,0DAAmB,YAAY,mGAAmG;AAClJ,gBAAgB,0DAAmB;AACnC,YAAY,0DAAmB,UAAU,kCAAkC;AAC3E,gBAAgB,0DAAmB;AACnC,gBAAgB,0DAAmB,YAAY,mHAAmH;AAClK,gBAAgB,0DAAmB;AACnC,YAAY,0DAAmB,UAAU,kCAAkC;AAC3E,gBAAgB,0DAAmB;AACnC,gBAAgB,0DAAmB,YAAY,2IAA2I;AAC1L,gBAAgB,0DAAmB;AACnC,YAAY,0DAAmB,UAAU,kCAAkC;AAC3E,gBAAgB,0DAAmB;AACnC,gBAAgB,0DAAmB,YAAY,qIAAqI;AACpL,gBAAgB,0DAAmB;AACnC,YAAY,0DAAmB,UAAU,kCAAkC;AAC3E,gBAAgB,0DAAmB,aAAa,gEAAgE;AAChH,gBAAgB,0DAAmB,aAAa,8CAA8C;AAC9F;AACO,6BAA6B,6DAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0DAAmB,sBAAsB,uDAAuD;AAChH;AACA","sources":["webpack://jupyterlab_mutableai/./lib/commands.js","webpack://jupyterlab_mutableai/./lib/connectors/connector.js","webpack://jupyterlab_mutableai/./lib/connectors/customConnector.js","webpack://jupyterlab_mutableai/./lib/handler.js","webpack://jupyterlab_mutableai/./lib/index.js","webpack://jupyterlab_mutableai/./lib/manager.js","webpack://jupyterlab_mutableai/./lib/plugin.js","webpack://jupyterlab_mutableai/./lib/tokens.js","webpack://jupyterlab_mutableai/./lib/widgets/Settings.js"],"sourcesContent":["export const invoke = 'completer:invoke';\nexport const invokeNotebook = 'completer:invoke-notebook-1';\nexport const select = 'completer:select';\nexport const selectNotebook = 'completer:select-notebook-custom';\nexport const toggleFlag = 'jupyterlab_mutableai/settings:toggle-flag';\nexport const updateSettings = 'jupyterlab_mutableai/settings:update-settings';\nexport const processFile = 'context_menu:open';\n","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n// Modified from jupyterlab/packages/completer/src/connector.ts\nimport { DataConnector } from '@jupyterlab/statedb';\n/**\n * A multi-connector connector for completion handlers.\n */\nexport class CompletionConnector extends DataConnector {\n    /**\n     * Create a new connector for completion requests.\n     *\n     * @param connectors - Connectors to request matches from, ordered by metadata preference (descending).\n     */\n    constructor(connectors) {\n        super();\n        this._connectors = connectors;\n    }\n    /**\n     * Fetch completion requests.\n     *\n     * @param request - The completion request text and details.\n     * @returns Completion reply\n     */\n    fetch(request) {\n        return Promise.all(this._connectors.map(connector => connector.fetch(request))).then(replies => {\n            const definedReplies = replies.filter((reply) => !!reply);\n            return Private.mergeReplies(definedReplies);\n        });\n    }\n}\n/**\n * A namespace for private functionality.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Merge results from multiple connectors.\n     *\n     * @param replies - Array of completion results.\n     * @returns IReply with a superset of all matches.\n     */\n    function mergeReplies(replies) {\n        // Filter replies with matches.\n        const repliesWithMatches = replies.filter(rep => rep.matches.length > 0);\n        // If no replies contain matches, return an empty IReply.\n        if (repliesWithMatches.length === 0) {\n            return replies[0];\n        }\n        // If only one reply contains matches, return it.\n        if (repliesWithMatches.length === 1) {\n            return repliesWithMatches[0];\n        }\n        // Collect unique matches from all replies.\n        const matches = new Set();\n        repliesWithMatches.forEach(reply => {\n            reply.matches.forEach(match => matches.add(match));\n        });\n        // Note that the returned metadata field only contains items in the first member of repliesWithMatches.\n        return Object.assign(Object.assign({}, repliesWithMatches[0]), { matches: [...matches] });\n    }\n    Private.mergeReplies = mergeReplies;\n})(Private || (Private = {}));\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { DataConnector } from '@jupyterlab/statedb';\nimport { requestAPI } from '../handler';\n/**\n * A custom connector for completion handlers.\n */\nexport class CustomConnector extends DataConnector {\n    /**\n     * Create a new custom connector for completion requests.\n     *\n     * @param options - The instatiation options for the custom connector.\n     */\n    constructor(options, panel, setting) {\n        super();\n        // @ts-ignore\n        this._editor = options.editor;\n        this._panel = panel;\n        this.setting = setting;\n    }\n    /**\n     * Fetch completion requests.\n     *\n     * @param request - The completion request text and details.\n     * @returns Completion reply\n     */\n    fetch(request) {\n        if (!this._editor) {\n            return Promise.reject('No editor');\n        }\n        return new Promise(resolve => {\n            const apiKey = this.setting.get('apiKey').composite;\n            const flag = this.setting.get('flag').composite;\n            const enabled = this.setting.get('enabled').composite;\n            const autocompleteDomain = this.setting.get('autocompleteDomain')\n                .composite;\n            resolve(Private.completionHint(\n            // @ts-ignore\n            this._editor, this._panel, autocompleteDomain, apiKey, flag && enabled));\n        });\n    }\n}\n/**\n * A namespace for Private functionality.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Get a list of mocked completion hints.\n     *\n     * @param editor Editor\n     * @returns Completion reply\n     */\n    async function completionHint(editor, panel, domain, apiKey, flag) {\n        // Find the token at the cursor\n        const cursor = editor.getCursorPosition();\n        const token = editor.getTokenForPosition(cursor);\n        // get source of all cells\n        const cells = panel.content.widgets;\n        // get index of active cell\n        // @ts-ignore\n        const index = cells.indexOf(panel.content.activeCell);\n        // get all cells up to index\n        const cellsUpToIndex = cells.slice(0, index + 1);\n        // get all cells after index\n        const cellsAfterIndex = cells.slice(index + 1);\n        // append cellsUpToIndex to cellsAfterIndex\n        const cellsToComplete = cellsAfterIndex.concat(cellsUpToIndex);\n        // get source code of all cells\n        const sources = cellsToComplete.map(cell => cell.model.value.text);\n        // concatenate sources, this will be used as a prompt\n        const prompt = sources.join('\\n\\n');\n        console.log('prompt: ' + prompt);\n        // Get all text in the editor\n        //const activeCellText = editor.model.value.text;\n        // get token string\n        const tokenString = token.value;\n        // Send to handler\n        // TODO: rename this line to prompt\n        const dataToSend = { line: prompt, domain, apiKey, flag };\n        // POST request\n        let reply = requestAPI('AUTOCOMPLETE', {\n            body: JSON.stringify(dataToSend),\n            method: 'POST'\n        });\n        const response = await reply;\n        // Get size of text so that you can remove it from response\n        //const size = previousText.length;\n        //console.log(\"size of text: \" + size);\n        // Remove initial text in response\n        // const responseText = response.slice(size);\n        console.log('response: ' + response);\n        // Create a list of matching tokens.\n        const tokenList = [\n            { value: tokenString + response, offset: token.offset, type: 'AI' }\n            //{ value: token.value + 'Magic', offset: token.offset, type: 'magic' },\n            //{ value: token.value + 'Neither', offset: token.offset },\n        ];\n        //console.log(\"value and offset\")\n        //console.log(token.value)\n        //console.log(token.offset)\n        // Only choose the ones that have a non-empty type field, which are likely to be of interest.\n        const completionList = tokenList.filter(t => t.type).map(t => t.value);\n        // Remove duplicate completions from the list\n        const matches = Array.from(new Set(completionList));\n        return {\n            start: token.offset,\n            end: token.offset + token.value.length,\n            matches,\n            metadata: {}\n        };\n    }\n    Private.completionHint = completionHint;\n})(Private || (Private = {}));\n","import { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestAPI(endPoint = '', init = {}) {\n    // Make request to Jupyter API\n    const settings = ServerConnection.makeSettings();\n    const requestUrl = URLExt.join(settings.baseUrl, 'jupyterlab-mutableai', // API Namespace\n    endPoint);\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    let data = await response.text();\n    if (data.length > 0) {\n        try {\n            data = JSON.parse(data);\n        }\n        catch (error) {\n            console.log('Not a JSON response body.', response);\n        }\n    }\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message || data);\n    }\n    return data;\n}\n","import plugin from './plugin';\nexport { IMutableAI } from './tokens';\nexport default plugin;\n","import { MainMenu } from '@jupyterlab/mainmenu';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { toggleFlag, updateSettings } from './commands';\nexport class MutableAIManager {\n    constructor(options) {\n        var _a;\n        this._ready = new PromiseDelegate();\n        this._mutableAI = null;\n        this.mutableAiMainMenu = null;\n        this._translator = (_a = options.translator) !== null && _a !== void 0 ? _a : nullTranslator;\n        this._mainMenu = options.mainMenu;\n        this._commands = options.commands;\n        this._contextMenu = options.contextMenu;\n        this._processFilePointer = null;\n        options\n            .getSettings()\n            .then(mutableAI => {\n            this._mutableAI = mutableAI;\n            this._mutableAI.changed.connect(this._mutableAISettingsChanged, this);\n            this._mutableAISettingsChanged();\n            this._ready.resolve();\n        })\n            .catch(reason => {\n            console.warn(reason);\n            this._ready.reject(reason);\n        });\n    }\n    /*\n      Mutable AI manager extension enable port.\n    */\n    enable() {\n        var _a;\n        (_a = this._mutableAI) === null || _a === void 0 ? void 0 : _a.set('enabled', true);\n    }\n    /*\n      Mutable AI manager extension disable port.\n    */\n    disable() {\n        var _a;\n        (_a = this._mutableAI) === null || _a === void 0 ? void 0 : _a.set('enabled', false);\n    }\n    /*\n      Mutable AI manager extension initialization.\n    */\n    initializePlugin() {\n        var _a;\n        this.dispose();\n        const enabled = (_a = this._mutableAI) === null || _a === void 0 ? void 0 : _a.get('enabled').composite;\n        if (enabled) {\n            const trans = this._translator.load('jupyterlab');\n            this.mutableAiMainMenu = MainMenu.generateMenu(this._commands, {\n                id: 'mutable-ai-settings',\n                label: 'Mutable AI Settings',\n                rank: 80\n            }, trans);\n            this.mutableAiMainMenu.addGroup([\n                {\n                    command: toggleFlag\n                },\n                {\n                    command: updateSettings\n                }\n            ]);\n            this._mainMenu.addMenu(this.mutableAiMainMenu, { rank: 80 });\n            this._processFilePointer = this._contextMenu.addItem({\n                command: 'context_menu:open',\n                selector: '.jp-DirListing-item[data-file-type=\"notebook\"]',\n                rank: 0\n            });\n        }\n    }\n    /*\n      Mutable AI manager extension dispose.\n    */\n    dispose() {\n        var _a, _b;\n        (_a = this.mutableAiMainMenu) === null || _a === void 0 ? void 0 : _a.dispose();\n        (_b = this._processFilePointer) === null || _b === void 0 ? void 0 : _b.dispose();\n    }\n    /**\n     * A promise that resolves when the settings have been loaded.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * Mutable AI manager change extension according to settings.\n     */\n    _mutableAISettingsChanged() {\n        var _a;\n        const enabled = (_a = this._mutableAI) === null || _a === void 0 ? void 0 : _a.get('enabled').composite;\n        if (enabled) {\n            this.initializePlugin();\n        }\n        else {\n            this.dispose();\n        }\n    }\n}\n","import { ContextConnector, ICompletionManager, KernelConnector } from '@jupyterlab/completer';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { INotebookTracker } from '@jupyterlab/notebook';\nimport { IFileBrowserFactory } from '@jupyterlab/filebrowser';\nimport { fastForwardIcon } from '@jupyterlab/ui-components';\nimport { MainAreaWidget } from '@jupyterlab/apputils';\nimport { settingsIcon } from '@jupyterlab/ui-components';\nimport { SettingsWidget } from './widgets/Settings';\nimport { IMainMenu } from '@jupyterlab/mainmenu';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { CompletionConnector } from './connectors/connector';\nimport { CustomConnector } from './connectors/customConnector';\nimport { requestAPI } from './handler';\nimport { PLUGIN_ID, IMutableAI } from './tokens';\nimport { invoke, invokeNotebook, select, selectNotebook, toggleFlag, updateSettings, processFile } from './commands';\nimport { MutableAIManager } from './manager';\nconst plugin = {\n    id: PLUGIN_ID,\n    autoStart: true,\n    provides: IMutableAI,\n    requires: [\n        IFileBrowserFactory,\n        ISettingRegistry,\n        IMainMenu,\n        ITranslator,\n        INotebookTracker,\n        ICompletionManager\n    ],\n    activate: (app, factory, settings, mainMenu, translator, notebooks, completionManager) => {\n        const { commands, contextMenu } = app;\n        /*\n          Initialized main mutableAI manager object.\n        */\n        const manager = new MutableAIManager({\n            translator,\n            mainMenu,\n            commands,\n            contextMenu,\n            getSettings: () => settings.load(PLUGIN_ID)\n        });\n        console.log('Mutable AI context menu is activated!');\n        let flag = true;\n        /**\n         * Load the settings for this extension\n         *\n         * @param setting Extension settings\n         */\n        function loadSetting(setting) {\n            // Read the settings and convert to the correct type\n            flag = setting.get('flag').composite;\n        }\n        // Wait for the application to be restored and\n        // for the settings for this plugin to be loaded\n        Promise.all([app.restored, settings.load(PLUGIN_ID)]).then(([, setting]) => {\n            // Read the settings\n            loadSetting(setting);\n            // Listen for your plugin setting changes using Signal\n            setting.changed.connect(loadSetting);\n            /*\n              Mutable AI toggle AutoComplete flag in main menu command.\n            */\n            commands.addCommand(toggleFlag, {\n                label: 'AutoComplete',\n                isToggled: () => flag,\n                execute: () => {\n                    // Programmatically change a setting\n                    Promise.all([setting.set('flag', !flag)])\n                        .then(() => {\n                        const newFlag = setting.get('flag').composite;\n                        console.log(`Mutable AI updated flag to '${newFlag ? 'enabled' : 'disabled'}'.`);\n                    })\n                        .catch(reason => {\n                        console.error(`Something went wrong when changing the settings.\\n${reason}`);\n                    });\n                }\n            });\n            /*\n              Mutable AI update settings in main menu command.\n            */\n            commands.addCommand(updateSettings, {\n                label: 'Update Mutable AI Settings',\n                execute: () => {\n                    const close = () => { var _a; return (_a = app.shell.currentWidget) === null || _a === void 0 ? void 0 : _a.close(); };\n                    const content = new SettingsWidget(setting, close);\n                    const widget = new MainAreaWidget({ content });\n                    widget.title.label = 'MutableAI Settings';\n                    widget.title.icon = settingsIcon;\n                    app.shell.add(widget, 'main');\n                }\n            });\n            /*\n              Mutable AI transform file in context menu command.\n            */\n            commands.addCommand(processFile, {\n                label: 'Fast Forward to Production with MutableAI',\n                caption: 'Mutable AI context menu.',\n                icon: fastForwardIcon,\n                execute: () => {\n                    var _a;\n                    const file = (_a = factory.tracker.currentWidget) === null || _a === void 0 ? void 0 : _a.selectedItems().next();\n                    const apiKey = setting.get('apiKey').composite;\n                    const transformDomain = setting.get('transformDomain')\n                        .composite;\n                    const dataToSend = { name: file === null || file === void 0 ? void 0 : file.path, apiKey, transformDomain };\n                    // POST request\n                    const reply = requestAPI('TRANSFORM_NB', {\n                        body: JSON.stringify(dataToSend),\n                        method: 'POST'\n                    });\n                    // Log to console\n                    reply\n                        .then(response => console.log('Transformed Successfully!'))\n                        .catch(e => console.log('Transformation failed!', e));\n                }\n            });\n            notebooks.widgetAdded.connect((sender, panel) => {\n                var _a, _b;\n                let editor = (_b = (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n                const session = panel.sessionContext.session;\n                const options = { session, editor };\n                const connector = new CompletionConnector([]);\n                const handler = completionManager.register({\n                    connector,\n                    editor,\n                    parent: panel\n                });\n                const updateConnector = () => {\n                    var _a, _b;\n                    editor = (_b = (_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor) !== null && _b !== void 0 ? _b : null;\n                    options.session = panel.sessionContext.session;\n                    options.editor = editor;\n                    handler.editor = editor;\n                    const kernel = new KernelConnector(options);\n                    const context = new ContextConnector(options);\n                    /*\n                     * The custom connector is getting initialized with settings.\n                     * This is used to get the updated settings while making the\n                     * completer api call.\n                     */\n                    const custom = new CustomConnector(options, panel, setting);\n                    handler.connector = new CompletionConnector([\n                        custom,\n                        kernel,\n                        context\n                    ]);\n                };\n                // Update the handler whenever the prompt or session changes\n                panel.content.activeCellChanged.connect(updateConnector);\n                panel.sessionContext.sessionChanged.connect(updateConnector);\n            });\n            // Add notebook completer command.\n            app.commands.addCommand(invokeNotebook, {\n                execute: () => {\n                    var _a;\n                    const panel = notebooks.currentWidget;\n                    if (panel && ((_a = panel.content.activeCell) === null || _a === void 0 ? void 0 : _a.model.type) === 'code') {\n                        return app.commands.execute(invoke, {\n                            id: panel.id\n                        });\n                    }\n                }\n            });\n            // Add notebook completer select command.\n            app.commands.addCommand(selectNotebook, {\n                execute: () => {\n                    const id = notebooks.currentWidget && notebooks.currentWidget.id;\n                    if (id) {\n                        return app.commands.execute(select, { id });\n                    }\n                }\n            });\n            // Set enter key for notebook completer select command.\n            app.commands.addKeyBinding({\n                command: selectNotebook,\n                keys: ['Enter'],\n                selector: '.jp-Notebook .jp-mod-completer-active'\n            });\n        });\n        return manager;\n    }\n};\nexport default plugin;\n","import { Token } from '@lumino/coreutils';\nconst BASE = 'jupyterlab_mutableai';\nexport const PLUGIN_ID = `${BASE}:IMutableAI`;\nexport const IMutableAI = new Token(`${BASE}:IMutableAI`);\n","import { ReactWidget } from '@jupyterlab/apputils';\nimport { showDialog, Dialog } from '@jupyterlab/apputils';\nimport React, { useState, useEffect } from 'react';\nconst SettingsComponent = (props) => {\n    const { setting, close } = props;\n    const [autoCompleteFlag, setAutoCompleteFlag] = useState(false);\n    const [apiKey, setApiKey] = useState('');\n    const [autocompleteDomain, setAutocompleteDomain] = useState('');\n    const [transformDomain, setTransformDomain] = useState('');\n    const setValues = () => {\n        // Read the settings and convert to the correct type\n        setAutoCompleteFlag(setting.get('flag').composite);\n        setApiKey(setting.get('apiKey').composite);\n        setAutocompleteDomain(setting.get('autocompleteDomain').composite);\n        setTransformDomain(setting.get('transformDomain').composite);\n    };\n    const restoreToDefault = () => {\n        /*\n         * This fetches the default settings from\n         * user settings then sets then sets it\n         * in the form. But as the form is not\n         * submitted it is not saved until save\n         * button is pressed.\n         */\n        const flagDefault = setting.default('flag');\n        const apiKeyDefault = setting.default('apiKey');\n        const autocompleteDomainDefault = setting.default('autocompleteDomain');\n        const transformDomainDefault = setting.default('transformDomain');\n        setAutoCompleteFlag(flagDefault);\n        setApiKey(apiKeyDefault);\n        setAutocompleteDomain(autocompleteDomainDefault);\n        setTransformDomain(transformDomainDefault);\n        setting.set('flag', flagDefault);\n        setting.set('apiKey', apiKeyDefault);\n        setting.set('autocompleteDomain', autocompleteDomainDefault);\n        setting.set('transformDomain', transformDomainDefault);\n    };\n    /*\n     * Whenever the settings object is changed from\n     * outside the widget it updates the form accordingly.\n     */\n    setting.changed.connect(setValues);\n    useEffect(() => {\n        /*\n         * When the widget is attached.\n         * It gets the last values from\n         * settings object and updates the\n         * settings form.\n         */\n        setValues();\n    }, []);\n    const handleSubmit = (e) => {\n        /*\n         * This function gets the submitted form\n         * It then updates the values from form-data\n         * After that the latest data is saved in user-settings.\n         * Also after successful saving it shows a\n         */\n        e.preventDefault();\n        const okButton = Dialog.okButton({\n            className: 'btn jp-mutableai-modal-btn'\n        });\n        try {\n            setting.set('flag', autoCompleteFlag);\n            setting.set('apiKey', apiKey);\n            setting.set('autocompleteDomain', autocompleteDomain);\n            setting.set('transformDomain', transformDomain);\n            // Success dialog.\n            showDialog({\n                title: 'Mutable AI Settings',\n                body: 'The changes saved successfully!',\n                buttons: [okButton]\n            });\n        }\n        catch (e) {\n            // Error dialog.\n            showDialog({\n                title: 'Mutable AI Settings',\n                body: 'Something went wrong saving settings. Reason: ' + e.toString(),\n                buttons: [okButton]\n            });\n        }\n    };\n    return (React.createElement(\"div\", { className: \"jp-mutableai-container\" },\n        React.createElement(\"h1\", null, \"Mutable AI Settings\"),\n        React.createElement(\"div\", { className: \"jp-mutableai-header\" },\n            React.createElement(\"button\", { className: \"btn btn-secondary\", type: \"button\", onClick: restoreToDefault }, \"Restore to Defaults\")),\n        React.createElement(\"form\", { className: \"jp-mutableai-form\", onSubmit: handleSubmit },\n            React.createElement(\"div\", { className: \"jp-mutableai-group \" },\n                React.createElement(\"label\", null, \"Autocomplete Flag\"),\n                React.createElement(\"input\", { type: \"checkbox\", checked: autoCompleteFlag, onChange: e => setAutoCompleteFlag(e.target.checked) }),\n                React.createElement(\"span\", null, \"This controls whether or not autocomplete is activated.\")),\n            React.createElement(\"div\", { className: \"jp-mutableai-group \" },\n                React.createElement(\"label\", null, \"API key\"),\n                React.createElement(\"input\", { className: \"form-control\", placeholder: \"\", type: \"text\", value: apiKey, onChange: e => setApiKey(e.target.value) }),\n                React.createElement(\"span\", null, \"This is the api key to call the endpoints.\")),\n            React.createElement(\"div\", { className: \"jp-mutableai-group \" },\n                React.createElement(\"label\", null, \"Autocomplete Domain\"),\n                React.createElement(\"input\", { className: \"form-control\", placeholder: \"\", type: \"text\", value: autocompleteDomain, onChange: e => setAutocompleteDomain(e.target.value) }),\n                React.createElement(\"span\", null, \"Used to construct url to call autocomplete endpoint\")),\n            React.createElement(\"div\", { className: \"jp-mutableai-group \" },\n                React.createElement(\"label\", null, \"Transform Domain\"),\n                React.createElement(\"input\", { className: \"form-control\", placeholder: \"\", type: \"text\", value: transformDomain, onChange: e => setTransformDomain(e.target.value) }),\n                React.createElement(\"span\", null, \"Used to construct url to call transform endpoint\")),\n            React.createElement(\"div\", { className: \"jp-mutableai-footer\" },\n                React.createElement(\"button\", { className: \"btn btn-secondary\", type: \"button\", onClick: close }, \"Cancel\"),\n                React.createElement(\"button\", { className: \"btn btn-success\", type: \"submit\" }, \"Save\")))));\n};\nexport class SettingsWidget extends ReactWidget {\n    constructor(setting, close) {\n        super();\n        // This is the top widget class for settings widget.\n        this.addClass('jp-mutableai-widget');\n        // settings object passed here is used.\n        // This is used to get, set, update\n        // mutable AI settings.\n        this.setting = setting;\n        // This is used to close the shell.\n        this.closeShell = close;\n    }\n    render() {\n        // This is the settings component passed to the widget.\n        return (React.createElement(SettingsComponent, { setting: this.setting, close: () => this.closeShell() }));\n    }\n}\n"],"names":[],"sourceRoot":""}