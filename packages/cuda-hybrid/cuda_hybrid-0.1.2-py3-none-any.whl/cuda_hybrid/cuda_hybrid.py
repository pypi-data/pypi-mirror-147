"""lestone3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1USKzHm8oC6ai4WNVn2RKjtnfWm6zV7id
"""
import networkx as nx
import numba
from numba import cuda
from numba.typed import Dict
from numba.cuda.random import create_xoroshiro128p_states
from numba.cuda.random import xoroshiro128p_uniform_float64
from networkx.algorithms.community import greedy_modularity_communities
from networkx.algorithms import community
from nptyping import NDArray, Float64
import numpy as np
import random
import math
from typing import Tuple
from statistics import mean
import sys

class HybridModel:
    def __init__(self, ABM: nx.Graph, community_algorithm=None):
        self.ABM = ABM
        self.agent_indices = {}
        for i, node in enumerate(ABM.nodes()):
            self.agent_indices[node] = i
        (
            self.ABM_adj,
            self.FCM_adj,
            self.fcm_labels,
            self.node_val,
            self.node_future_val,
        ) = HybridModel.transformNetwork(ABM)
        # map agent node label to index in node_val, future_val (useful
        # for Simulation class)
        if community_algorithm != None:
            self.community_algorithm = community_algorithm
            # list of numpy arrays containing members for each community

            self.communities, self.random_interaction_list = self.generate_communities()

    #USED
    def influence(influenced, influencing):
        """Models the influence, influencing equation found
        in Dr. Giabbanelli's paper

        Args:
            influenced ([float]): [compared to measure how much one is influenced]
            influencing ([float]): [compared against influencing for probability]

        Returns:
            [int]: [the influenced value to be assigned to the node]
        """
        probability = random.random()
        if influencing > influenced:
            # print('more')
            if random.random() < probability:
                # print('prob')
                return influencing
        elif influencing < influenced:
            # print('less')
            if random.random() < 1 - probability:
                return influencing
        return influenced
    #USED
    def get_neighbors(self, node: int) -> list:
        """Get neighbors for node in an adjacency matrix representation of a graph

        Args:
            adj (NDArray[Float64]): adjacency matrix in graph
            node (int): the node for which neighbors are fest

        Returns:
            list: a list of neighbors
        """
        ret = []
        # loop through the adjacency matrix to append the list of neighbors
        for i in range(self.ABM_adj.shape[1]):
            if self.ABM_adj[node][i] > 0:
                ret.append(i)

        return ret

    # USED
    def interaction(self):
        """Simulate interaction between agents in our agent based model
        graph """
        # loop through the agents
        # dont simulate for single agent communities
        if self.ABM_adj.shape[0] <= 1:
            return

        for agent in range(self.ABM_adj.shape[0]):
            # grab the neighbors and randomly choose one
            friends = self.get_neighbors(agent)
            friend = random.choice(friends)
            # for each influenced concept
            for influenced in range(self.FCM_adj.shape[1]):
                # for each influencing concept
                for influencing in range(self.FCM_adj.shape[1]):
                    self.node_future_val[agent][influenced] = 1 / (1 + math.exp(-1 * 
                        HybridModel.influence(
                            self.node_val[agent][influenced],
                            self.node_val[friend][influencing],
                        )
                    ))

    # run fuzzy cognitive map for a given agent
    # USED
    def runFCM(self, focus, threshold, max_it=100):
        """ Runs fuzzy cognitive map for all agents

        """

        # loop through the adjacency matrix for each agent
        for agent in range(self.ABM_adj.shape[0]):
            it = 0
            # sentinel value so that the loop doesnt stop immediately (idiot python has no do ... while)
            oldVals = [100] * len(focus)
            # loop until the FCM has stabilized (no significant change)
            while (it < max_it):
                # check all focus concepts, if all have stabilized then
                # break outer while loop
                all_stable = True
                for i, f in enumerate(focus):
                    if abs(self.node_val[agent][self.fcm_labels[f]] - oldVals[i]) / oldVals[i] > threshold[i]:
                        all_stable = False
                        break
                if all_stable:
                    break
                # loop through each concept in the FCM adjacency matrix
                oldVals = [self.node_val[agent][self.fcm_labels[f]] for f in focus]
                for concept in range(self.FCM_adj.shape[0]):
                    weightSum = 0

                    # grab each edge and value of the FCM
                    for edge in range(self.FCM_adj.shape[1]):

                        # update the values
                        if self.FCM_adj[edge][concept] != 0:
                            weightSum += (
                                self.FCM_adj[edge][concept]
                                * self.node_val[agent][edge]
                            )
                    # update the new value of the FCM node
                    #self.node_future_val[agent][concept] = 1 / (1 + np.exp(-(self.node_val[agent][concept] + weightSum
                    #)))
                    self.node_future_val[agent][concept] = math.tanh(self.node_val[agent][concept] + weightSum)
                self.loadNewValues()
                it += 1
    # USED
    def loadNewValues(self) -> None:
        """ Sets FCM values to future values for each FCM in each agent infrom numba import cuda
    the simulation

        Args:
            node_val (NDArray[Float64]): node value matrix for each agent
            node_future_val (NDArray[Float64]): future node value matrix for each agent
        """
        # loop through the agents in the matrix
        for agent in range(self.node_val.shape[0]):
            # update the new concept values of the node
            for concept in range(self.node_val.shape[1]):
                self.node_val[agent][concept] = self.node_future_val[agent][concept]
    # USED
    def run(self, focus, threshold, iters, func, argv, steps=100) -> float:
        """Run the model through simulation for the obesity value on sim2

        Args:
            steps (int): [This is amount of steps/itations]

        Returns:
            float: [obesity value]
        """
        # loop through the amount of steps and simulate
        for _ in range(steps):
            self.interact_serial(focus, threshold, iters, func, argv)

        result_values = {}

        # loop through the agent values and update obesity value
        for f in focus:
            for agent in range(self.node_val.shape[0]):
                result_values[f] = result_values.get(f, 0) + self.node_val[agent][self.fcm_labels[f]]
            result_values[f] /= self.node_val.shape[0]

        return result_values

    # USED
    def interact_serial(self, focus, threshold, iters, func, argv):
        """Simulate all of the social influence interactions between agents,
    then stabilize all of the agents respective FCMs
        """

        # for each agent (vertex)
        # for each neighbor influencing agent (incident edge)
        # for each concept influenced by peers
        # update the value of the concept
        # buffer = nx.Graph.copy(ABM)
        # self.interaction()
        func(*argv)
        # load new FCM values
        self.loadNewValues()
        # now stabilize FCM for every agent
        self.runFCM(focus, threshold, iters)

    # need list of all neighbors
    # check if the neighbor chosen from list is in betweenComms if so do this
    # else proceed as regular
    # USED
    def between_community_interaction(self):
        """Simulate interaction between agents in our agent based model
        graph """
        # loop through the agents that are between communities
        for agent in self.between_comms:
            friend = random.choice(self.between_comms[agent])
            for influenced in range(np.shape(self.FCM_adj)[1]):
                # for each influencing concept
                for influencing in range(np.shape(self.FCM_adj)[1]):
                    # print(ABM.nodes[agent]['FCM'].nodes[influenced]['val'], buffer.nodes[agent]['FCM'].nodes[influenced]['val'])
                    self.node_future_val[self.agent_indices[agent]][
                        influenced
                    ] = 1 / (1 + math.exp(-1 * 
                        HybridModel.influence(
                            self.node_val[self.agent_indices[agent]][influenced],
                            self.node_val[self.agent_indices[friend]][influencing],
                        )
                    ))
    # USED
    def run_parallel(self, BPG, TPB, focus, threshold, iters, args, between_args, steps):
        """Iterates through the simulation and assigns
        for each block per grid and thread per block

        Args:
            it ([int]): [amount of times to itate]
            BPG ([int]): [blocks per grid]
            TPB ([int]): [threads per grid]
        """
        foci = []
        for f in focus:
            foci.append(self.fcm_labels[f])
        old_vals = np.full(len(foci), 100, dtype=np.float32)
        #cu_old_vals = cuda.to_device(old_vals)
        cu_focus = cuda.to_device(foci)
        cu_community_list = cuda.to_device(self.communities)
        cu_ABM_adj = cuda.to_device(self.ABM_adj)
        cu_FCM_adj = cuda.to_device(self.FCM_adj)
        #cu_node_future_val = cuda.to_device(self.node_future_val)
        #cu_node_val = cuda.to_device(self.node_val)
        cu_random_interaction_list = cuda.to_device(self.random_interaction_list)
        cu_threshold = cuda.to_device(threshold)
        cu_args = cuda.to_device(args)
        rng_states = create_xoroshiro128p_states(1, seed=42069)

        results = {}
        # for each simulation step
        for i in range(steps):
            # run the kernel (runs each community)
            cuda.synchronize()
            kernel[BPG, TPB](
            #kernel[1, 1024](
              cu_community_list,
              #self.communities,
              cu_ABM_adj,
              cu_FCM_adj,
              self.node_future_val,
              self.node_val,
              cu_random_interaction_list,
              cu_focus,
              # self.fcm_labels[focus],
              cu_threshold,
              iters,
              rng_states,
              old_vals,
              cu_args
            )
            cuda.synchronize()

            # print(f"step {i+1} of {steps}")

            # retrieve results from GPU
            #self.node_val = cu_node_val.copy_to_host()
            #self.node_future_val = cu_node_future_val.copy_to_host()
            self.loadNewValues()
            # do between community interactions
            between_community_interaction(*between_args)
            # load all buffered values
            self.loadNewValues()
            #cu_node_future_val = cuda.to_device(self.node_future_val)
            #cu_node_val = cuda.to_device(self.node_val)
            cuda.synchronize()
            runFCMCUDA[self.ABM_adj.shape[0]//32, 32](
            #runFCMCUDA[1, 1024](
              cu_community_list,
              #self.communities,
              cu_ABM_adj,
              cu_FCM_adj,
              self.node_future_val,
              self.node_val,
              iters,
              cu_focus,
              # self.fcm_labels[focus],
              cu_threshold,
              old_vals
            )
            cuda.synchronize()
            #self.node_val = cu_node_val.copy_to_host()
            #self.node_future_val = cu_node_future_val.copy_to_host()
            self.loadNewValues()

            # append obesity value
        #print(foci)
        for f in focus:
            #print(f)
            for agent in range(self.node_val.shape[0]):
                #print(results.get(f, 0), self.node_val[agent][f])
                results[f] = results.get(f, 0) + self.node_val[agent][self.fcm_labels[f]]
            results[f] /= self.node_val.shape[0]
            # obesity_values.append(
            #    mean(
            #        self.node_val[agent][self.fcm_labels[focus]]
            #        for agent in range(self.ABM_adj.shape[0])
            #    )
            # )
        print(self.node_val)
        cuda.synchronize()
        cuda.close()
        return results

    # USED
    def generate_communities(self):
        """ Generate subgraphs for each community and assemble a list
            mapping each node to the community containing it. Also create a list of
            the nodes that fall between communities and their neighbors in other
            communities. Regenerate communities if there is one of size one (could
            fix this later)

        Returns:
            list: numpy arrays for each community
        """
        # map between community nodes to a list of their neighbors
        self.between_comms = {}
        # map node number in G => index of its community in community list
        self.node_community_map = {}

        communities = list(list(comm) for comm in self.community_algorithm(self.ABM))
        community_matrix = np.zeros(
            shape=(len(communities), max([len(community) for community in communities]))
        )
        subgraphs = []
        # random choice matrix : random choices within community for each node for interaction stage
        # did not want to generate on gpu
        for community_idx, community in enumerate(communities):
            subgraph = self.ABM.subgraph(community)
            subgraphs.append(subgraph)
            # loop through the list and grab the node neighbors
            for agent_idx in range(community_matrix.shape[1]):
                # fill with negative ones if this row contains more columns than we need to list agents in this community
                if agent_idx >= len(community):
                    community_matrix[community_idx][agent_idx] = -1
                else:
                    node = community[agent_idx]
                    community_matrix[community_idx][agent_idx] = self.agent_indices[
                        node
                    ]
                    self.node_community_map[node] = community_idx
                    # loop through the neighbors list
                    for neighbor in self.ABM.neighbors(node):
                        if neighbor not in subgraph.neighbors(node):
                            if node not in self.between_comms:
                                self.between_comms[node] = [neighbor]
                            else:
                                self.between_comms[node].append(neighbor)

        random_interaction_list = np.zeros(shape=(len(self.ABM.nodes())), dtype=int)
        for node in self.ABM.nodes():
            random_interaction_list[self.agent_indices[node]] = self.agent_indices[
                random.choice(list(subgraphs[self.node_community_map[node]].neighbors(node)))
            ]
        return community_matrix, random_interaction_list

    # Turn matrix into numpy array
    # transform network into adjacency matrix
    # fcm_labels for each node in each agents fcm
    # numpy matrix with fcm values for each agent
    # numpy matrix with future fcm values for each agent
    # numpy adjacency matrix for FCM with edge weights
    # USED
    def transformNetwork(
        G: nx.Graph,
    ) -> Tuple[
        NDArray[Float64], NDArray[Float64], Dict, NDArray[Float64], NDArray[Float64]
    ]:
        """Transforms a network into an adjacency matrix, fcm_labels for each node
        in each agent's FCM, numpy matrix with FCM values for each agent, a
        numpy matrix with future fcm values for each agent, and a numpy
        adjacency matrix with FCM edge weights.
        Args:
            G (nx.Graph): networkX graph to transform

        Returns:
            NDArray, NDArray, Dict, NDArray, NDArray: adjacency matrix, fcm_labels
            for each node in each agent's FCM, numpy matrix with FCM values
            for each agent, numpy matrix with future FCM values for each
            agent, numpy adjacency matrix with FCM edge weights
        """

        # set values of ABM and FCM matrix
        ABM_adj = nx.to_numpy_array(G, dtype=np.float32)
        FCM_adj = nx.to_numpy_array(G.nodes[list(G.nodes())[0]]["FCM"], dtype=np.float32)

        # create dictionary for fcm_labels
        fcm_labels = Dict()

        # store the node values and future node values that will serve as a buffer
        node_val = np.zeros(
            (len(G.nodes()), len(G.nodes[list(G.nodes())[0]]["FCM"].nodes())), dtype=np.float32
        )
        node_future_val = np.zeros(
            (len(G.nodes()), len(G.nodes[list(G.nodes())[0]]["FCM"].nodes())), dtype=np.float32
        )

        # create a nested loop of the FCM node attribute and the value
        for i, node in enumerate(G.nodes(data="FCM")):
            for j, fcm_node in enumerate(node[1].nodes(data="val")):
                # store this value
                node_val[i][j] = fcm_node[1]
                node_future_val[i][j] = fcm_node[1]

        print(node_val)
        # loop though and just get the names of the attribute for labeling
        for i, node in enumerate(G.nodes[list(G.nodes())[0]]["FCM"].nodes()):
            fcm_labels[node] = i

        return ABM_adj, FCM_adj, fcm_labels, node_val, node_future_val

# USED
def create_FCM_file(filename) -> nx.DiGraph:
    """Creates the obesity FCM Dr. Giabbanelli gave us

    Returns:
        nx.DiGraph: a directed graph object with the FCM data
    """
    FCM = nx.read_edgelist(filename, nodetype=str, data=(('weight', float),), create_using=nx.DiGraph())

    for node in FCM.nodes():
        FCM.nodes[node]["val"] = np.random.random()
    return FCM

# USED
def create_graph(agent_count, graph_type, filename):
    """[summary]

    Args:
        agent_count ([int]): [Number of nodes we want to run on]

    Returns:
        [networkx graph]: graph
    """

    G = nx.Graph()

    # networkx functions to create our graphs
    if graph_type == "watts":
        G = nx.watts_strogatz_graph(agent_count, 4, 0)

    elif graph_type == "sf":
        G = nx.scale_free_graph(agent_count).to_undirected()
        G.remove_edges_from(list(nx.selfloop_edges(G)))

    elif graph_type == "newman":
        G = nx.newman_watts_strogatz_graph(agent_count, 2, 2)

    elif graph_type == "barabasi":
        G = nx.barabasi_albert_graph(agent_count, 2)
    else:
        sys.exit("Please enter one of the following graph generators: watts, sf, newman, barabasi")

    #loop through attacht the FCM
    for agent in G.nodes():
            G.nodes[agent]["FCM"] = create_FCM_file(filename)
    return G

def call_interaction_serial(func, *argv):
    func(*argv)

@cuda.jit(device=True, )
def call_interaction(community_list, ABM_adj, FCM_adj, node_val, node_future_val, random_interaction_list, rng_states, args):
    f(community_list, ABM_adj, FCM_adj, node_val, node_future_val, random_interaction_list, rng_states, args)

#@cuda.jit(device=True, )
#def call_interaction(community_list, ABM_adj, FCM_adj, node_val, node_future_val, random_interaction_list, rng_states):
    #f(community_list, ABM_adj, FCM_adj, node_val, node_future_val, random_interaction_list, rng_states)


def generate_model(agent_count, filename, graph_type, community_algorithm):
    G = create_graph(agent_count, graph_type, filename)

    hm = HybridModel(G, community_algorithm)
    return hm

# USED
def run_cuda(hm, focus, threshold, iters, args=np.array([], dtype=int), between_args=[], steps=20):
    # create a scale free and small world graph
    TPB = (32, 32)
    blockspergrid_x = math.ceil(len(hm.ABM.nodes()) / TPB[0])
    blockspergrid_y = math.ceil(len(hm.ABM.nodes()) / TPB[1])
    BPG = (blockspergrid_x, blockspergrid_y)
    results = hm.run_parallel(BPG, TPB, focus, threshold, iters, args, between_args, steps)
    for f, val in results.items():
        print(f"average {f}: {val}")
    # print(f"average {focus}: {hm.run_parallel(BPG, TPB, focus, threshold, iters, args)}")

# USED
@cuda.jit(device=True, )
def loadNewValuesCUDA(community_list, node_val, node_future_val) -> None:
    """ Sets FCM values to future values for each FCM in each agent infrom numba import cuda
the simulation

    Args:
        node_val (NDArray[Float64]): node value matrix for each agent
        node_future_val (NDArray[Float64]): future node value matrix for each agent

    """
    # get the i, j position of the cuda grid
    x = cuda.grid(1)

    # check the position of the values and make sure it stays in bounds
    #if x < len(community_list[x]) and community_list[x][y] != -1:
    if x < node_val.shape[0]:
        agent_idx = int(x)    
        #agent_idx = int(community_list[x][y])
        for concept in range(node_val.shape[1]):
            node_val[agent_idx][concept] = node_future_val[agent_idx][concept]
            cuda.syncthreads()

# USED
@cuda.jit()
def runFCMCUDA(
    community_list, ABM_adj, FCM_adj, node_future_val, node_val, max_it, focus, threshold, old_vals
):
    """ Runs fuzzy cognitive map for all agents

    Args:
        FCM_adj (NDArray[Float64]): Adjacency matrix for each FCM
        fcm_labels (Dict): fcm_labels for the agents
        node_vals (NDArray[Float64]): current values of each fcm node
        for each agent
        future_vals (NDArray[Float64]): future values of each fcm node
        for each agent
        max_it (int, optional): Maximum iterations for stabilization. Defaults to 100.
        focus (str, optional): The concept that we're trying to stabilize. Defaults to "Obesity".
    """
    # grab the position of the grid of the CUDA
    x = cuda.grid(1)

    # check, focus if this thread's x coordinate corresponds to an agent in our community list
    #if x < len(community_list[x]) and community_list[x][y] != -1:
    #if x < community_list.shape[0] and y < community_list.shape[1] and community_list[x][y] != -1:
    if x < ABM_adj.shape[0]:
        #agent = int(community_list[x][y])
        agent = int(x)
        # focusIdx = int(focus[focusIdx])
        it = 0
        oldVals = old_vals

        # similar to serial we loop until we have a significant change
        while (
            it < max_it
        ):
            # check all focus concepts, if all have stabilized then
            # break outer while loop
            all_stable = True
            for i in range(len(focus)):
                if abs(node_val[agent][focus[i]] - oldVals[i]) / oldVals[i] > threshold[i]:
                    all_stable = False
                    break
            if all_stable:
                break
            for i in range(len(focus)):
                oldVals[i] = node_future_val[agent][focus[i]]
            cuda.syncthreads()
            # loop through the concept nodes in the FCM
            for concept in range(FCM_adj.shape[0]):
                weightSum = 0

                # loop through the edge values
                for edge in range(FCM_adj.shape[1]):
                    if FCM_adj[edge][concept] != 0:
                        weightSum += FCM_adj[edge][concept] * node_val[agent][edge]
                # store the new value of the node
                #node_future_val[agent][concept] = 1 / (1 + math.exp(-1 * 
                #    node_val[agent][concept] + weightSum
                #))
                node_future_val[agent][concept] = math.tanh(
                    node_val[agent][concept] + weightSum
                )
                cuda.syncthreads()
            # increase the iteration
            loadNewValuesCUDA(community_list, node_val, node_future_val)
            it += 1

# steps for the model:
# 1: simulate all of the social influence interactions between agents
# 2: stabilize all of the agents fcms
# ABM_adj, FCM_adj, fcm_labels, node_val, node_future_val
# USED
@cuda.jit(device=True)
def sim(
    community_list,
    ABM_adj,
    FCM_adj,
    node_val,
    node_future_val,
    random_interaction_list,
    focus,
    threshold,
    iters,
    rng_states,
    old_vals,
    args
):
    """Simulate all of the social influence interactions between agents,
then stabilize all of the agents respective FCMs

    Args:
        ABM_adj (NDArray[Float64]): Adjacency matrix for ABM social relationships
        FCM_adj (NDArray[Float64]): Adjacency matrix for each FCM
        fcm_labels (Dict): dictionary of unique fcm_labels for agents
        node_val (NDArray[Float64]): node value matrix for each agent
        node_future_val (NDArray[Float64]): future node value matrix for each agent
    """

    # for each agent (vertex)
    # for each neighbor influencing agent (incident edge)
    # for each concept influenced by peers
    # update the value of the concept
    # buffer = nx.Graph.copy(ABM)
    #if len(args) >= 1:
    call_interaction(community_list, ABM_adj, FCM_adj, node_val, node_future_val, random_interaction_list, rng_states, args)
    #else:
    #call_interaction(community_list, ABM_adj, FCM_adj, node_val, node_future_val, random_interaction_list, rng_states)
    #interaction_cuda(
    #    community_list,
    #    ABM_adj,
    #    FCM_adj,
    #    node_val,
    #    node_future_val,
    #    random_interaction_list,
    #    rng_states
    #)

    #loadNewValuesCUDA(community_list, node_val, node_future_val)

    #runFCMCUDA(community_list, ABM_adj, FCM_adj, node_future_val, node_val, iters, focus, threshold, old_vals)

# USED
@cuda.jit(device=True)
def influence_cuda(influenced, influencing, rng_states):
    """Models the influence, influencing equation found
    in Dr. Giabbanelli's paper

    Args:
        influenced ([int]): [compared to measure how much one is influenced]
        influencing ([int]): [compared against influencing for probability]

    Returns:
        [int]: [the influenced value to be assigned to the node]
    """
    thread_id = cuda.grid(1)
    #probability = xoroshiro128p_uniform_float64(rng_states, thread_id)
    probability = 0
    if influencing > influenced:
        if xoroshiro128p_uniform_float64(rng_states, thread_id) < probability:
            return influencing
    elif influencing < influenced:
        if xoroshiro128p_uniform_float64(rng_states, thread_id) < 1 - probability:
           return influencing
    return influenced

# USED
@cuda.jit(device=True, )
def f(
    community_list, ABM_adj, FCM_adj, node_val, node_future_val, random_interaction_list, rng_states, args
):
    """Simulate interaction between agents in our agent based model
    graph """

    x, y = cuda.grid(2)
    #if x < len(community_list[y]) and community_list[y][x] != -1:
    if x < community_list.shape[0] and y < community_list.shape[1] and community_list[x][y] != -1:
        agent = int(community_list[x][y])
        # we already randomly selected the friend before sending to GPU
        friend = random_interaction_list[agent]
        knowledgeIdx = args[0]
        node_future_val[agent][knowledgeIdx] = influence_cuda(node_val[agent][knowledgeIdx], node_val[friend][knowledgeIdx], rng_states)
        cuda.syncthreads()
        #for influenced in range(FCM_adj.shape[1]):
            # for each influencing concept
            #for influencing in range(FCM_adj.shape[1]):
                #node_future_val[agent][influenced] = 1 / (1 + math.exp(-1 * influence_cuda(
                #        node_val[agent][influenced], node_val[friend][influencing], rng_states
                #    )
                #))
                



# this is the kernel
# USED
@cuda.jit()
def kernel(
    community_list,
    ABM_adj,
    FCM_adj,
    node_future_val,
    node_val,
    random_interaction_list,
    focus,
    threshold,
    iters,
    rng_states,
    old_vals,
    args
):
    """run all the community models on cuda

    Args:
        community_models ([list]): [Holds the list of subgraphs]
    """
    x, y = cuda.grid(2)
    # y = number of communities
    # x = nodes in a community
    #if y < len(community_list):
        # do the run stuff for community x
        # call the sim method here instead
    if y < community_list.shape[0] and x < community_list.shape[1]:     
        sim(
            community_list,
            ABM_adj,
            FCM_adj,
            node_future_val,
            node_val,
            random_interaction_list,
            focus,
            threshold,
            iters,
            rng_states,
            old_vals,
            args
        )

@cuda.jit()
def kernel_no_args(
    community_list,
    ABM_adj,
    FCM_adj,
    node_future_val,
    node_val,
    random_interaction_list,
    focus,
    threshold,
    iters,
    rng_states
):
    """run all the community models on cuda

    Args:
        community_models ([list]): [Holds the list of subgraphs]
    """
    #x, y = cuda.grid(2)
    # y = number of communities
    # x = nodes in a community
    #if y < len(community_list):
        # do the run stuff for community x
        # call the sim method here instead
    sim_no_args(
        community_list,
        ABM_adj,
        FCM_adj,
        node_future_val,
        node_val,
        random_interaction_list,
        focus,
        threshold,
        iters,
        rng_states
    )


def main(agent_count, graph_type, filename, focus, threshold, iters, *argv):
    # Replications (10 default)
    G = create_graph(agent_count, graph_type, filename)
    hm = HybridModel(G)
    # hm.run(focus)
    results = hm.run(focus, threshold, iters, *argv)
    for focus, value in results.items():
        print(f"average {focus}: {value}")

def run_serial(hm, focus, threshold, iters, func, argv, steps=20):
    # Replications (10 default)
    # hm.run(focus)
    results = hm.run(focus, threshold, iters, func, argv, steps)
    for focus, value in results.items():
        print(f"average {focus}: {value}")


def influence(influenced, influencing):
    """Models the influence, influencing equation found
    in Dr. Giabbanelli's paper

    Args:
        influenced ([float]): [compared to measure how much one is influenced]
        influencing ([float]): [compared against influencing for probability]

    Returns:
        [int]: [the influenced value to be assigned to the node]
    """
    probability = random.random()
    if influencing > influenced:
        # print('more')
        if random.random() < probability:
            # print('prob')
            return influencing
    elif influencing < influenced:
        # print('less')
        if random.random() < 1 - probability:
            return influencing
    return influenced

def interaction(hm):
    """Simulate interaction between agents in our agent based model
    graph """
    # loop through the agents
    # dont simulate for single agent communities
    if hm.ABM_adj.shape[0] <= 1:
        return

    for agent in range(hm.ABM_adj.shape[0]):
        # grab the neighbors and randomly choose one
        friends = hm.get_neighbors(agent)
        friend = random.choice(friends)
        # for each influenced concept
        for influenced in range(hm.FCM_adj.shape[1]):
            # for each influencing concept
            for influencing in range(hm.FCM_adj.shape[1]):
                hm.node_future_val[agent][influenced] = influence(
                        hm.node_val[agent][influenced],
                        hm.node_val[friend][influencing],
                )

def knowledge_influence(influenced, influencing):
    """Models the influence, influencing equation found
    in Dr. Giabbanelli's paper

    Args:
        influenced ([float]): [compared to measure how much one is influenced]
        influencing ([float]): [compared against influencing for probability]

    Returns:
        [int]: [the influenced value to be assigned to the node]
    """
    probability = 0
    if influencing > influenced:
        # print('more')
        if random.random() < probability:
            # print('prob')
            return influencing
    elif influencing < influenced:
        # print('less')
        if random.random() < 1 - probability:
            return influencing
    return influenced

def obesity_interact(hm):
    if hm.ABM_adj.shape[0] <= 1:
        return
    # loop through each agent
    for agent in range(hm.ABM_adj.shape[0]):
        # grab the neighbors
        friend = random.choice(hm.get_neighbors(agent))
        # get the numeric index for EconomicDevelopment and AbilityOfInsurgentsToControlThePopulation
        knowledgeIdx = hm.fcm_labels["Knowledge"]
        # agents now influence each other
        hm.node_future_val[agent][knowledgeIdx] = knowledge_influence(
            hm.node_val[agent][knowledgeIdx], hm.node_val[friend][knowledgeIdx]
        )

def between_community_interaction(hm):
    # loop through each agent
    used_interactions = []
    for agent in hm.between_comms:
        # grab the neighbors
        friend = random.choice(hm.between_comms[agent])
        if (agent, friend) in used_interactions or (friend, agent) in used_interactions:
            continue
        used_interactions.append((agent, friend))
        # get the numeric index for EconomicDevelopment and AbilityOfInsurgentsToControlThePopulation
        knowledgeIdx = hm.fcm_labels["Knowledge"]
        # agents now influence each other
        hm.node_future_val[agent][knowledgeIdx] = knowledge_influence(
            hm.node_val[agent][knowledgeIdx], hm.node_val[friend][knowledgeIdx]
        )

def insurgency_interact(hm):
    if hm.ABM_adj.shape[0] <= 1:
        return
    # loop through each agent
    for agent in range(hm.ABM_adj.shape[0]):
        # grab the neighbors
        friends = hm.get_neighbors(agent)
        # get the numeric index for EconomicDevelopment and AbilityOfInsurgentsToControlThePopulation
        econIdx = hm.fcm_labels["EconomicDevelopment"]
        insurgeIdx = hm.fcm_labels["AbilityOfInsurgentsToControlThePopulation"]
        econList = []
        insurgeList = []
        # get the list of values for all the neighbors for the two concepts
        for friend in friends:
            econList.append(hm.node_val[friend][econIdx])
            insurgeList.append(hm.node_val[friend][insurgeIdx])
        # agents now influence each other
        hm.node_future_val[agent][econIdx] = econ_influence(
                hm.node_val[agent][econIdx],
                econList
        )
        hm.node_future_val[agent][econIdx] = insurgency_influence(
                hm.node_future_val[agent][econIdx],
                insurgeList
        )

@cuda.jit(device=True, )
def f_insurgency(community_list, ABM_adj, FCM_adj, node_val, node_future_val, random_interaction_list, rng_states, args):
    x, y = cuda.grid(2)
    if x < len(community_list[y]) and community_list[y][x] != -1:
        agent = int(community_list[y][x])
        # grab the neighbors
        friends = community_list[y]
        # get the numeric index for EconomicDevelopment and AbilityOfInsurgentsToControlThePopulation
        econIdx = args[0]
        insurgeIdx = args[1]
        # econList = np.zeros(len(community_list[y]))
        # insurgeList = np.zeros(len(community_list[y]))
        # get the list of values for all the neighbors for the two concepts
        resultEcon = float(node_val[agent][econIdx])
        res = 0.0
        for friend in range(len(friends)):
            res += float(node_val[friend][econIdx])
        lowerThresh = 1 - 5 / 100.0
        upperThresh = 1 + 5 / 100.0
        if res > resultEcon * lowerThresh:
            resultEcon = float(node_val[agent][econIdx]) + float(node_val[agent][econIdx]) * (1 + 5 / 100.0)
        elif res < resultEcon * upperThresh:
            resultEcon = float(node_val[agent][econIdx]) + float(node_val[agent][econIdx]) * (1 - 5 / 100.0)
        # agents now influence each other
        node_future_val[agent][econIdx] = resultEcon
        resultInsur = node_future_val[agent][econIdx]
        for friend in  range(len(friends)):
            resultInsur -= .1 * node_val[friend][insurgeIdx]
        #node_future_val[agent][econIdx] = econ_influence(
        #        node_val[agent][econIdx],
        #        econList
        #)
        node_future_val[agent][econIdx] = resultInsur / (len(community_list[y]) - 1)
        #node_future_val[agent][econIdx] = insurgency_influence(
        #        node_future_val[agent][econIdx],
        #        insurgeList
        #)

def insurgency_influence(influencedVal, influencing):
    rate = 0.1
    avg = 0.0
    result = influencedVal
    for num in influencing:
        result -= rate * num
        # avg += num
    avg /= len(influencing)
    # result = influencedVal - rate * avg
    return result

def econ_influence(val, influencing):
    threshold = 5
    impact = 5
    avg = 0.0
    for num in influencing:
        avg += num
    lowerThresh = 1 - threshold / 100.0
    upperThresh = 1 + threshold / 100.0
    result = val
    if avg > val * upperThresh:
        result = val + val * (1 + impact / 100.0)
    elif avg < val * lowerThresh:
        result = val + val * (1 - impact / 100.0)
    return result

def create_obesity_FCM():
    FCM = nx.read_edgelist('obesity.txt', nodetype=str, data=(('weight', float),), create_using=nx.DiGraph())
    #nx.draw(FCM, with_labels = True)
    FCM.nodes["Fatness_Perceived_as_Negative"]["val"] = 0.8
    FCM.nodes["Belief_in_Personal_Responsibility"]["val"] = 0.8
    #FCM.nodes["Exercise"]["val"] = rand_invgauss(1.53, 1, 0.01)
    FCM.nodes["Exercise"]["val"] = np.random.wald(1, 0.01)
    num = FCM.nodes["Exercise"]["val"] + 30.0/11000.0
    FCM.nodes["Food_Intake"]["val"] = num if num < 1 else 1
    #FCM.nodes["Knowledge"]["val"] = rand_invgauss2(1, 0.01)
    FCM.nodes["Knowledge"]["val"] = np.random.wald(1, 0.01)
    # Age-related concepts
    ageInd = int(np.random.choice(AGE_RELATED[:, 0], p = AGE_RELATED[:, 1]/100) - 18)
    FCM.nodes["Age"]["val"] = AGE_RELATED[ageInd][2]
    propStressed = AGE_RELATED[ageInd][4] / 100
    FCM.nodes["Stress"]["val"] = np.random.choice([0, 1], p = [1-propStressed, propStressed])
    propDepressed = AGE_RELATED[ageInd][3] / 100
    FCM.nodes["Depression"]["val"] = np.random.choice([0, 1], p = [1-propDepressed, propDepressed])
    FCM.nodes["Antidepressants"]["val"] = 0
    if FCM.nodes["Depression"]["val"] == 1:
        propAnti = AGE_RELATED[ageInd][5] / 100
        FCM.nodes["Antidepressants"]["val"] = np.random.choice([0, 1], p = [1-propAnti, propAnti])
    propHealth = AGE_RELATED[ageInd][9] / 100
    FCM.nodes["Physical_Health"]["val"] = np.random.choice([0, 1], p = [1-propHealth, propHealth])
    probObesity = AGE_RELATED[ageInd][6:9] / 100
    FCM.nodes["Obesity"]["val"] = np.random.choice([0, 0.5, 1], p = probObesity)
    FCM.nodes["Weight_Discrimination"]["val"] = FCM.nodes["Obesity"]["val"]
    FCM.nodes["Income"]["val"] = np.random.choice(INCOME[:, 0], p = INCOME[:, 1]/100)
    return FCM


if __name__ == "__main__":
    # choose whether to run the default or cuda implementation
    # syntax python milestone3.py (number of nodes) (cuda)

    #if len(sys.argv) != 8 and len(sys.argv) != 9:
    #    print(
    #        "Syntax: python milestone3.py (number of nodes) (cuda/serial) (FCM file) (focus) (threshold) (iterations) (sw/sf) (greedy/label). Last argument cuda mode only ",
    #        file=sys.stderr,
    #    )
    #    exit(1)

    #agent_count = int(sys.argv[1])
    #mode = sys.argv[2]
    #filename = sys.argv[3]
    #focus = sys.argv[4]
    #threshold = float(sys.argv[5])
    #iters = int(sys.argv[6])

    #print(f"running {agent_count} nodes for graph type in {mode}")
    #if mode == "cuda":
    #    graph_type = sys.argv[-2]
    #    comm_algo = (
    #        greedy_modularity_communities
    #        if sys.argv[-1] == "greedy"
    #        else nx.community.label_propagation_communities
    #    )
    #    print(f"community algorithm: {comm_algo}")
    #    cuda_main(agent_count, filename, focus, threshold, iters, graph_type, comm_algo)
    #else:
    #    graph_type = sys.argv[-1]
    #    main(agent_count, graph_type, filename, focus, threshold, iters)
    # RUNS IN SERIAL
    #G = create_graph(100, 'watts', 'obesity.txt')
    AGE_RELATED = np.loadtxt('age_related.txt')
    INCOME = np.loadtxt('income.txt')
    G = nx.watts_strogatz_graph(2412, 11, .05)
    for agent in G.nodes():
            G.nodes[agent]["FCM"] = create_obesity_FCM()
    #hm = HybridModel(G, nx.community.label_propagation_communities)
    hm = HybridModel(G, nx.algorithms.community.greedy_modularity_communities)
    #run_serial(hm, ["Obesity", "Physical_Health"], [0.05, 0.05], 10, obesity_interact, [hm], 20)
    #main2(hm, ['Obesity', 'Physical_Health'], [.05, .05], 10, obesity_interact, hm)
    # RUNS CUDA
    # hm = generate_model(100, 'obesity.txt', 'watts', nx.community.label_propagation_communities)
    knowIdx = hm.fcm_labels['Knowledge']
    #econIdx = hm.fcm_labels['EconomicDevelopment']
    #insurIdx = hm.fcm_labels["AbilityOfInsurgentsToControlThePopulation"]
    #run_cuda(hm, ['Rebelliousness'], [.05], 10, np.array([econIdx, insurIdx], dtype=int))
    run_cuda(hm, ['Obesity'], [.05], 10, np.array([knowIdx], dtype=int), [hm], 20)
