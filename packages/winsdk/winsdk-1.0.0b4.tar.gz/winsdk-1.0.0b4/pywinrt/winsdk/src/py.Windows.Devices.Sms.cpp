// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.4

#include "pybase.h"
#include "py.Windows.Devices.Sms.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsAppMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsBroadcastMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsDevice2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsFilterRule>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsFilterRules>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsMessageRegistration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsSendMessageResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsStatusMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsTextMessage2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsVoicemailMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsWapMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::ISmsMessageBase>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Sms::SmsEncodedLength>::python_type;

PyObject* py::converter<winrt::Windows::Devices::Sms::SmsEncodedLength>::convert(winrt::Windows::Devices::Sms::SmsEncodedLength instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Devices::Sms::SmsEncodedLength>());
}
winrt::Windows::Devices::Sms::SmsEncodedLength py::converter<winrt::Windows::Devices::Sms::SmsEncodedLength>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::Sms::SmsEncodedLength>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Sms::SmsEncodedLength>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Devices::Sms::SmsEncodedLength or dict");
        throw python_exception();
    }

    winrt::Windows::Devices::Sms::SmsEncodedLength return_value{};

    PyObject* py_SegmentCount = PyDict_GetItemString(obj, "segment_count");
    if (!py_SegmentCount) {
        PyErr_SetString(PyExc_KeyError, "SegmentCount");
        throw python_exception();
    }
    return_value.SegmentCount = converter<uint32_t>::convert_to(py_SegmentCount);

    PyObject* py_CharacterCountLastSegment = PyDict_GetItemString(obj, "character_count_last_segment");
    if (!py_CharacterCountLastSegment) {
        PyErr_SetString(PyExc_KeyError, "CharacterCountLastSegment");
        throw python_exception();
    }
    return_value.CharacterCountLastSegment = converter<uint32_t>::convert_to(py_CharacterCountLastSegment);

    PyObject* py_CharactersPerSegment = PyDict_GetItemString(obj, "characters_per_segment");
    if (!py_CharactersPerSegment) {
        PyErr_SetString(PyExc_KeyError, "CharactersPerSegment");
        throw python_exception();
    }
    return_value.CharactersPerSegment = converter<uint32_t>::convert_to(py_CharactersPerSegment);

    PyObject* py_ByteCountLastSegment = PyDict_GetItemString(obj, "byte_count_last_segment");
    if (!py_ByteCountLastSegment) {
        PyErr_SetString(PyExc_KeyError, "ByteCountLastSegment");
        throw python_exception();
    }
    return_value.ByteCountLastSegment = converter<uint32_t>::convert_to(py_ByteCountLastSegment);

    PyObject* py_BytesPerSegment = PyDict_GetItemString(obj, "bytes_per_segment");
    if (!py_BytesPerSegment) {
        PyErr_SetString(PyExc_KeyError, "BytesPerSegment");
        throw python_exception();
    }
    return_value.BytesPerSegment = converter<uint32_t>::convert_to(py_BytesPerSegment);

    return return_value;
}

namespace py::cpp::Windows::Devices::Sms
{
    // ----- SmsAppMessage class --------------------
    constexpr const char* const _type_name_SmsAppMessage = "SmsAppMessage";

    static PyObject* _new_SmsAppMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsAppMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsAppMessage(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsAppMessage_get_ProtocolId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtocolId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_ProtocolId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ProtocolId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_PortNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PortNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_PortNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.PortNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDeliveryNotificationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDeliveryNotificationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RetryAttemptCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.RetryAttemptCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_Encoding(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Encoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_Encoding(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsEncoding>(arg);

            self->obj.Encoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_Body(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Body(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallbackNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CallbackNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_BinaryBody(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BinaryBody());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_BinaryBody(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.BinaryBody(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_To(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.To(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_TeleserviceId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TeleserviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsAppMessage_put_TeleserviceId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TeleserviceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsAppMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsAppMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsAppMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsAppMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsAppMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsAppMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsAppMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsAppMessage[] = {
        { "protocol_id", reinterpret_cast<getter>(SmsAppMessage_get_ProtocolId), reinterpret_cast<setter>(SmsAppMessage_put_ProtocolId), nullptr, nullptr },
        { "port_number", reinterpret_cast<getter>(SmsAppMessage_get_PortNumber), reinterpret_cast<setter>(SmsAppMessage_put_PortNumber), nullptr, nullptr },
        { "is_delivery_notification_enabled", reinterpret_cast<getter>(SmsAppMessage_get_IsDeliveryNotificationEnabled), reinterpret_cast<setter>(SmsAppMessage_put_IsDeliveryNotificationEnabled), nullptr, nullptr },
        { "retry_attempt_count", reinterpret_cast<getter>(SmsAppMessage_get_RetryAttemptCount), reinterpret_cast<setter>(SmsAppMessage_put_RetryAttemptCount), nullptr, nullptr },
        { "encoding", reinterpret_cast<getter>(SmsAppMessage_get_Encoding), reinterpret_cast<setter>(SmsAppMessage_put_Encoding), nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsAppMessage_get_Body), reinterpret_cast<setter>(SmsAppMessage_put_Body), nullptr, nullptr },
        { "callback_number", reinterpret_cast<getter>(SmsAppMessage_get_CallbackNumber), reinterpret_cast<setter>(SmsAppMessage_put_CallbackNumber), nullptr, nullptr },
        { "binary_body", reinterpret_cast<getter>(SmsAppMessage_get_BinaryBody), reinterpret_cast<setter>(SmsAppMessage_put_BinaryBody), nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsAppMessage_get_To), reinterpret_cast<setter>(SmsAppMessage_put_To), nullptr, nullptr },
        { "teleservice_id", reinterpret_cast<getter>(SmsAppMessage_get_TeleserviceId), reinterpret_cast<setter>(SmsAppMessage_put_TeleserviceId), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsAppMessage_get_From), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsAppMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsAppMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsAppMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsAppMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsAppMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsAppMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsAppMessage[] = 
    {
        { Py_tp_new, _new_SmsAppMessage },
        { Py_tp_dealloc, _dealloc_SmsAppMessage },
        { Py_tp_methods, _methods_SmsAppMessage },
        { Py_tp_getset, _getset_SmsAppMessage },
        { },
    };

    static PyType_Spec _type_spec_SmsAppMessage =
    {
        "_winsdk_Windows_Devices_Sms.SmsAppMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsAppMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsAppMessage
    };

    // ----- SmsBroadcastMessage class --------------------
    constexpr const char* const _type_name_SmsBroadcastMessage = "SmsBroadcastMessage";

    static PyObject* _new_SmsBroadcastMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsBroadcastMessage);
        return nullptr;
    }

    static void _dealloc_SmsBroadcastMessage(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsBroadcastMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_BroadcastType(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BroadcastType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_Channel(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_GeographicalScope(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GeographicalScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_IsEmergencyAlert(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEmergencyAlert());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_IsUserPopupRequested(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUserPopupRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_MessageCode(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_UpdateNumber(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsBroadcastMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsBroadcastMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsBroadcastMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsBroadcastMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsBroadcastMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsBroadcastMessage[] = {
        { "body", reinterpret_cast<getter>(SmsBroadcastMessage_get_Body), nullptr, nullptr, nullptr },
        { "broadcast_type", reinterpret_cast<getter>(SmsBroadcastMessage_get_BroadcastType), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(SmsBroadcastMessage_get_Channel), nullptr, nullptr, nullptr },
        { "geographical_scope", reinterpret_cast<getter>(SmsBroadcastMessage_get_GeographicalScope), nullptr, nullptr, nullptr },
        { "is_emergency_alert", reinterpret_cast<getter>(SmsBroadcastMessage_get_IsEmergencyAlert), nullptr, nullptr, nullptr },
        { "is_user_popup_requested", reinterpret_cast<getter>(SmsBroadcastMessage_get_IsUserPopupRequested), nullptr, nullptr, nullptr },
        { "message_code", reinterpret_cast<getter>(SmsBroadcastMessage_get_MessageCode), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsBroadcastMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsBroadcastMessage_get_To), nullptr, nullptr, nullptr },
        { "update_number", reinterpret_cast<getter>(SmsBroadcastMessage_get_UpdateNumber), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsBroadcastMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsBroadcastMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsBroadcastMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsBroadcastMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsBroadcastMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsBroadcastMessage[] = 
    {
        { Py_tp_new, _new_SmsBroadcastMessage },
        { Py_tp_dealloc, _dealloc_SmsBroadcastMessage },
        { Py_tp_methods, _methods_SmsBroadcastMessage },
        { Py_tp_getset, _getset_SmsBroadcastMessage },
        { },
    };

    static PyType_Spec _type_spec_SmsBroadcastMessage =
    {
        "_winsdk_Windows_Devices_Sms.SmsBroadcastMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsBroadcastMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsBroadcastMessage
    };

    // ----- SmsDevice2 class --------------------
    constexpr const char* const _type_name_SmsDevice2 = "SmsDevice2";

    static PyObject* _new_SmsDevice2(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsDevice2);
        return nullptr;
    }

    static void _dealloc_SmsDevice2(py::wrapper::Windows::Devices::Sms::SmsDevice2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsDevice2_CalculateLength(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::ISmsMessageBase>(args, 0);

                return py::convert(self->obj.CalculateLength(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sms::SmsDevice2::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_FromParentId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Sms::SmsDevice2::FromParentId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sms::SmsDevice2::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Sms::SmsDevice2::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_SendMessageAndGetResultAsync(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::ISmsMessageBase>(args, 0);

                return py::convert(self->obj.SendMessageAndGetResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_SmscAddress(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SmscAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsDevice2_put_SmscAddress(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SmscAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsDevice2_get_AccountPhoneNumber(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccountPhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_DeviceStatus(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_get_ParentDeviceId(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ParentDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_add_DeviceStatusChanged(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sms::SmsDevice2, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.DeviceStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsDevice2_remove_DeviceStatusChanged(py::wrapper::Windows::Devices::Sms::SmsDevice2* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DeviceStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsDevice2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsDevice2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsDevice2[] = {
        { "calculate_length", reinterpret_cast<PyCFunction>(SmsDevice2_CalculateLength), METH_VARARGS, nullptr },
        { "from_id", reinterpret_cast<PyCFunction>(SmsDevice2_FromId), METH_VARARGS | METH_STATIC, nullptr },
        { "from_parent_id", reinterpret_cast<PyCFunction>(SmsDevice2_FromParentId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(SmsDevice2_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(SmsDevice2_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "send_message_and_get_result_async", reinterpret_cast<PyCFunction>(SmsDevice2_SendMessageAndGetResultAsync), METH_VARARGS, nullptr },
        { "add_device_status_changed", reinterpret_cast<PyCFunction>(SmsDevice2_add_DeviceStatusChanged), METH_O, nullptr },
        { "remove_device_status_changed", reinterpret_cast<PyCFunction>(SmsDevice2_remove_DeviceStatusChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsDevice2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsDevice2[] = {
        { "smsc_address", reinterpret_cast<getter>(SmsDevice2_get_SmscAddress), reinterpret_cast<setter>(SmsDevice2_put_SmscAddress), nullptr, nullptr },
        { "account_phone_number", reinterpret_cast<getter>(SmsDevice2_get_AccountPhoneNumber), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsDevice2_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsDevice2_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_status", reinterpret_cast<getter>(SmsDevice2_get_DeviceStatus), nullptr, nullptr, nullptr },
        { "parent_device_id", reinterpret_cast<getter>(SmsDevice2_get_ParentDeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsDevice2[] = 
    {
        { Py_tp_new, _new_SmsDevice2 },
        { Py_tp_dealloc, _dealloc_SmsDevice2 },
        { Py_tp_methods, _methods_SmsDevice2 },
        { Py_tp_getset, _getset_SmsDevice2 },
        { },
    };

    static PyType_Spec _type_spec_SmsDevice2 =
    {
        "_winsdk_Windows_Devices_Sms.SmsDevice2",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsDevice2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsDevice2
    };

    // ----- SmsFilterRule class --------------------
    constexpr const char* const _type_name_SmsFilterRule = "SmsFilterRule";

    static PyObject* _new_SmsFilterRule(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsMessageType>(args, 0);

                winrt::Windows::Devices::Sms::SmsFilterRule instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsFilterRule(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsFilterRule_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsFilterRule_put_CellularClass(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::CellularClass>(arg);

            self->obj.CellularClass(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsFilterRule_get_BroadcastChannels(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BroadcastChannels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_BroadcastTypes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BroadcastTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_DeviceIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_ImsiPrefixes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImsiPrefixes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_PortNumbers(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PortNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_ProtocolIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtocolIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_SenderNumbers(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SenderNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_TeleserviceIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TeleserviceIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_TextMessagePrefixes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextMessagePrefixes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_WapApplicationIds(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WapApplicationIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRule_get_WapContentTypes(py::wrapper::Windows::Devices::Sms::SmsFilterRule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WapContentTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsFilterRule(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsFilterRule>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsFilterRule[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsFilterRule), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsFilterRule[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsFilterRule_get_CellularClass), reinterpret_cast<setter>(SmsFilterRule_put_CellularClass), nullptr, nullptr },
        { "broadcast_channels", reinterpret_cast<getter>(SmsFilterRule_get_BroadcastChannels), nullptr, nullptr, nullptr },
        { "broadcast_types", reinterpret_cast<getter>(SmsFilterRule_get_BroadcastTypes), nullptr, nullptr, nullptr },
        { "device_ids", reinterpret_cast<getter>(SmsFilterRule_get_DeviceIds), nullptr, nullptr, nullptr },
        { "imsi_prefixes", reinterpret_cast<getter>(SmsFilterRule_get_ImsiPrefixes), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsFilterRule_get_MessageType), nullptr, nullptr, nullptr },
        { "port_numbers", reinterpret_cast<getter>(SmsFilterRule_get_PortNumbers), nullptr, nullptr, nullptr },
        { "protocol_ids", reinterpret_cast<getter>(SmsFilterRule_get_ProtocolIds), nullptr, nullptr, nullptr },
        { "sender_numbers", reinterpret_cast<getter>(SmsFilterRule_get_SenderNumbers), nullptr, nullptr, nullptr },
        { "teleservice_ids", reinterpret_cast<getter>(SmsFilterRule_get_TeleserviceIds), nullptr, nullptr, nullptr },
        { "text_message_prefixes", reinterpret_cast<getter>(SmsFilterRule_get_TextMessagePrefixes), nullptr, nullptr, nullptr },
        { "wap_application_ids", reinterpret_cast<getter>(SmsFilterRule_get_WapApplicationIds), nullptr, nullptr, nullptr },
        { "wap_content_types", reinterpret_cast<getter>(SmsFilterRule_get_WapContentTypes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsFilterRule[] = 
    {
        { Py_tp_new, _new_SmsFilterRule },
        { Py_tp_dealloc, _dealloc_SmsFilterRule },
        { Py_tp_methods, _methods_SmsFilterRule },
        { Py_tp_getset, _getset_SmsFilterRule },
        { },
    };

    static PyType_Spec _type_spec_SmsFilterRule =
    {
        "_winsdk_Windows_Devices_Sms.SmsFilterRule",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsFilterRule),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsFilterRule
    };

    // ----- SmsFilterRules class --------------------
    constexpr const char* const _type_name_SmsFilterRules = "SmsFilterRules";

    static PyObject* _new_SmsFilterRules(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsFilterActionType>(args, 0);

                winrt::Windows::Devices::Sms::SmsFilterRules instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsFilterRules(py::wrapper::Windows::Devices::Sms::SmsFilterRules* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsFilterRules_get_ActionType(py::wrapper::Windows::Devices::Sms::SmsFilterRules* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsFilterRules_get_Rules(py::wrapper::Windows::Devices::Sms::SmsFilterRules* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rules());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsFilterRules(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsFilterRules>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsFilterRules[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsFilterRules), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsFilterRules[] = {
        { "action_type", reinterpret_cast<getter>(SmsFilterRules_get_ActionType), nullptr, nullptr, nullptr },
        { "rules", reinterpret_cast<getter>(SmsFilterRules_get_Rules), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsFilterRules[] = 
    {
        { Py_tp_new, _new_SmsFilterRules },
        { Py_tp_dealloc, _dealloc_SmsFilterRules },
        { Py_tp_methods, _methods_SmsFilterRules },
        { Py_tp_getset, _getset_SmsFilterRules },
        { },
    };

    static PyType_Spec _type_spec_SmsFilterRules =
    {
        "_winsdk_Windows_Devices_Sms.SmsFilterRules",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsFilterRules),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsFilterRules
    };

    // ----- SmsMessageReceivedTriggerDetails class --------------------
    constexpr const char* const _type_name_SmsMessageReceivedTriggerDetails = "SmsMessageReceivedTriggerDetails";

    static PyObject* _new_SmsMessageReceivedTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsMessageReceivedTriggerDetails);
        return nullptr;
    }

    static void _dealloc_SmsMessageReceivedTriggerDetails(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsMessageReceivedTriggerDetails_Accept(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Accept();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_Drop(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Drop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_AppMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_BroadcastMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BroadcastMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_StatusMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StatusMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_TextMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_VoicemailMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VoicemailMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageReceivedTriggerDetails_get_WapMessage(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WapMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsMessageReceivedTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsMessageReceivedTriggerDetails[] = {
        { "accept", reinterpret_cast<PyCFunction>(SmsMessageReceivedTriggerDetails_Accept), METH_VARARGS, nullptr },
        { "drop", reinterpret_cast<PyCFunction>(SmsMessageReceivedTriggerDetails_Drop), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsMessageReceivedTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsMessageReceivedTriggerDetails[] = {
        { "app_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_AppMessage), nullptr, nullptr, nullptr },
        { "broadcast_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_BroadcastMessage), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_MessageType), nullptr, nullptr, nullptr },
        { "status_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_StatusMessage), nullptr, nullptr, nullptr },
        { "text_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_TextMessage), nullptr, nullptr, nullptr },
        { "voicemail_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_VoicemailMessage), nullptr, nullptr, nullptr },
        { "wap_message", reinterpret_cast<getter>(SmsMessageReceivedTriggerDetails_get_WapMessage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsMessageReceivedTriggerDetails[] = 
    {
        { Py_tp_new, _new_SmsMessageReceivedTriggerDetails },
        { Py_tp_dealloc, _dealloc_SmsMessageReceivedTriggerDetails },
        { Py_tp_methods, _methods_SmsMessageReceivedTriggerDetails },
        { Py_tp_getset, _getset_SmsMessageReceivedTriggerDetails },
        { },
    };

    static PyType_Spec _type_spec_SmsMessageReceivedTriggerDetails =
    {
        "_winsdk_Windows_Devices_Sms.SmsMessageReceivedTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsMessageReceivedTriggerDetails
    };

    // ----- SmsMessageRegistration class --------------------
    constexpr const char* const _type_name_SmsMessageRegistration = "SmsMessageRegistration";

    static PyObject* _new_SmsMessageRegistration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsMessageRegistration);
        return nullptr;
    }

    static void _dealloc_SmsMessageRegistration(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsMessageRegistration_Register(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Sms::SmsFilterRules>(args, 1);

                return py::convert(winrt::Windows::Devices::Sms::SmsMessageRegistration::Register(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_Unregister(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Unregister();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_get_Id(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_get_AllRegistrations(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Sms::SmsMessageRegistration::AllRegistrations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_add_MessageReceived(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Sms::SmsMessageRegistration, winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsMessageRegistration_remove_MessageReceived(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsMessageRegistration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsMessageRegistration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsMessageRegistration[] = {
        { "register", reinterpret_cast<PyCFunction>(SmsMessageRegistration_Register), METH_VARARGS | METH_STATIC, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(SmsMessageRegistration_Unregister), METH_VARARGS, nullptr },
        { "get_all_registrations", reinterpret_cast<PyCFunction>(SmsMessageRegistration_get_AllRegistrations), METH_NOARGS | METH_STATIC, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(SmsMessageRegistration_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(SmsMessageRegistration_remove_MessageReceived), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsMessageRegistration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsMessageRegistration[] = {
        { "id", reinterpret_cast<getter>(SmsMessageRegistration_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsMessageRegistration[] = 
    {
        { Py_tp_new, _new_SmsMessageRegistration },
        { Py_tp_dealloc, _dealloc_SmsMessageRegistration },
        { Py_tp_methods, _methods_SmsMessageRegistration },
        { Py_tp_getset, _getset_SmsMessageRegistration },
        { },
    };

    static PyType_Spec _type_spec_SmsMessageRegistration =
    {
        "_winsdk_Windows_Devices_Sms.SmsMessageRegistration",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsMessageRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsMessageRegistration
    };

    // ----- SmsSendMessageResult class --------------------
    constexpr const char* const _type_name_SmsSendMessageResult = "SmsSendMessageResult";

    static PyObject* _new_SmsSendMessageResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsSendMessageResult);
        return nullptr;
    }

    static void _dealloc_SmsSendMessageResult(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsSendMessageResult_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_IsErrorTransient(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsErrorTransient());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_IsSuccessful(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSuccessful());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_MessageReferenceNumbers(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageReferenceNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_ModemErrorCode(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ModemErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_NetworkCauseCode(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkCauseCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsSendMessageResult_get_TransportFailureCause(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportFailureCause());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsSendMessageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsSendMessageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsSendMessageResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsSendMessageResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsSendMessageResult[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsSendMessageResult_get_CellularClass), nullptr, nullptr, nullptr },
        { "is_error_transient", reinterpret_cast<getter>(SmsSendMessageResult_get_IsErrorTransient), nullptr, nullptr, nullptr },
        { "is_successful", reinterpret_cast<getter>(SmsSendMessageResult_get_IsSuccessful), nullptr, nullptr, nullptr },
        { "message_reference_numbers", reinterpret_cast<getter>(SmsSendMessageResult_get_MessageReferenceNumbers), nullptr, nullptr, nullptr },
        { "modem_error_code", reinterpret_cast<getter>(SmsSendMessageResult_get_ModemErrorCode), nullptr, nullptr, nullptr },
        { "network_cause_code", reinterpret_cast<getter>(SmsSendMessageResult_get_NetworkCauseCode), nullptr, nullptr, nullptr },
        { "transport_failure_cause", reinterpret_cast<getter>(SmsSendMessageResult_get_TransportFailureCause), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsSendMessageResult[] = 
    {
        { Py_tp_new, _new_SmsSendMessageResult },
        { Py_tp_dealloc, _dealloc_SmsSendMessageResult },
        { Py_tp_methods, _methods_SmsSendMessageResult },
        { Py_tp_getset, _getset_SmsSendMessageResult },
        { },
    };

    static PyType_Spec _type_spec_SmsSendMessageResult =
    {
        "_winsdk_Windows_Devices_Sms.SmsSendMessageResult",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsSendMessageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsSendMessageResult
    };

    // ----- SmsStatusMessage class --------------------
    constexpr const char* const _type_name_SmsStatusMessage = "SmsStatusMessage";

    static PyObject* _new_SmsStatusMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsStatusMessage);
        return nullptr;
    }

    static void _dealloc_SmsStatusMessage(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsStatusMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_Status(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_DischargeTime(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DischargeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_MessageReferenceNumber(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageReferenceNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_ServiceCenterTimestamp(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceCenterTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsStatusMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsStatusMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsStatusMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsStatusMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsStatusMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsStatusMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsStatusMessage[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsStatusMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsStatusMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsStatusMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsStatusMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsStatusMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(SmsStatusMessage_get_Status), nullptr, nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsStatusMessage_get_Body), nullptr, nullptr, nullptr },
        { "discharge_time", reinterpret_cast<getter>(SmsStatusMessage_get_DischargeTime), nullptr, nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsStatusMessage_get_From), nullptr, nullptr, nullptr },
        { "message_reference_number", reinterpret_cast<getter>(SmsStatusMessage_get_MessageReferenceNumber), nullptr, nullptr, nullptr },
        { "service_center_timestamp", reinterpret_cast<getter>(SmsStatusMessage_get_ServiceCenterTimestamp), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsStatusMessage_get_To), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsStatusMessage[] = 
    {
        { Py_tp_new, _new_SmsStatusMessage },
        { Py_tp_dealloc, _dealloc_SmsStatusMessage },
        { Py_tp_methods, _methods_SmsStatusMessage },
        { Py_tp_getset, _getset_SmsStatusMessage },
        { },
    };

    static PyType_Spec _type_spec_SmsStatusMessage =
    {
        "_winsdk_Windows_Devices_Sms.SmsStatusMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsStatusMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsStatusMessage
    };

    // ----- SmsTextMessage2 class --------------------
    constexpr const char* const _type_name_SmsTextMessage2 = "SmsTextMessage2";

    static PyObject* _new_SmsTextMessage2(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsTextMessage2 instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SmsTextMessage2(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsTextMessage2_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RetryAttemptCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_RetryAttemptCount(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.RetryAttemptCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_To(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_To(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.To(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDeliveryNotificationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_IsDeliveryNotificationEnabled(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDeliveryNotificationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_Encoding(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Encoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_Encoding(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Sms::SmsEncoding>(arg);

            self->obj.Encoding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallbackNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_CallbackNumber(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CallbackNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_Body(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsTextMessage2_put_Body(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Body(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsTextMessage2_get_ProtocolId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtocolId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_From(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsTextMessage2_get_TeleserviceId(py::wrapper::Windows::Devices::Sms::SmsTextMessage2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TeleserviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsTextMessage2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsTextMessage2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsTextMessage2[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsTextMessage2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsTextMessage2[] = {
        { "message_type", reinterpret_cast<getter>(SmsTextMessage2_get_MessageType), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsTextMessage2_get_DeviceId), nullptr, nullptr, nullptr },
        { "cellular_class", reinterpret_cast<getter>(SmsTextMessage2_get_CellularClass), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsTextMessage2_get_MessageClass), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsTextMessage2_get_SimIccId), nullptr, nullptr, nullptr },
        { "retry_attempt_count", reinterpret_cast<getter>(SmsTextMessage2_get_RetryAttemptCount), reinterpret_cast<setter>(SmsTextMessage2_put_RetryAttemptCount), nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsTextMessage2_get_To), reinterpret_cast<setter>(SmsTextMessage2_put_To), nullptr, nullptr },
        { "is_delivery_notification_enabled", reinterpret_cast<getter>(SmsTextMessage2_get_IsDeliveryNotificationEnabled), reinterpret_cast<setter>(SmsTextMessage2_put_IsDeliveryNotificationEnabled), nullptr, nullptr },
        { "encoding", reinterpret_cast<getter>(SmsTextMessage2_get_Encoding), reinterpret_cast<setter>(SmsTextMessage2_put_Encoding), nullptr, nullptr },
        { "callback_number", reinterpret_cast<getter>(SmsTextMessage2_get_CallbackNumber), reinterpret_cast<setter>(SmsTextMessage2_put_CallbackNumber), nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsTextMessage2_get_Body), reinterpret_cast<setter>(SmsTextMessage2_put_Body), nullptr, nullptr },
        { "protocol_id", reinterpret_cast<getter>(SmsTextMessage2_get_ProtocolId), nullptr, nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsTextMessage2_get_From), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsTextMessage2_get_Timestamp), nullptr, nullptr, nullptr },
        { "teleservice_id", reinterpret_cast<getter>(SmsTextMessage2_get_TeleserviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsTextMessage2[] = 
    {
        { Py_tp_new, _new_SmsTextMessage2 },
        { Py_tp_dealloc, _dealloc_SmsTextMessage2 },
        { Py_tp_methods, _methods_SmsTextMessage2 },
        { Py_tp_getset, _getset_SmsTextMessage2 },
        { },
    };

    static PyType_Spec _type_spec_SmsTextMessage2 =
    {
        "_winsdk_Windows_Devices_Sms.SmsTextMessage2",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsTextMessage2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsTextMessage2
    };

    // ----- SmsVoicemailMessage class --------------------
    constexpr const char* const _type_name_SmsVoicemailMessage = "SmsVoicemailMessage";

    static PyObject* _new_SmsVoicemailMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsVoicemailMessage);
        return nullptr;
    }

    static void _dealloc_SmsVoicemailMessage(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsVoicemailMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_Body(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_MessageCount(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsVoicemailMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsVoicemailMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsVoicemailMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsVoicemailMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsVoicemailMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsVoicemailMessage[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsVoicemailMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsVoicemailMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsVoicemailMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsVoicemailMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsVoicemailMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { "body", reinterpret_cast<getter>(SmsVoicemailMessage_get_Body), nullptr, nullptr, nullptr },
        { "message_count", reinterpret_cast<getter>(SmsVoicemailMessage_get_MessageCount), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsVoicemailMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsVoicemailMessage_get_To), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsVoicemailMessage[] = 
    {
        { Py_tp_new, _new_SmsVoicemailMessage },
        { Py_tp_dealloc, _dealloc_SmsVoicemailMessage },
        { Py_tp_methods, _methods_SmsVoicemailMessage },
        { Py_tp_getset, _getset_SmsVoicemailMessage },
        { },
    };

    static PyType_Spec _type_spec_SmsVoicemailMessage =
    {
        "_winsdk_Windows_Devices_Sms.SmsVoicemailMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsVoicemailMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsVoicemailMessage
    };

    // ----- SmsWapMessage class --------------------
    constexpr const char* const _type_name_SmsWapMessage = "SmsWapMessage";

    static PyObject* _new_SmsWapMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SmsWapMessage);
        return nullptr;
    }

    static void _dealloc_SmsWapMessage(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SmsWapMessage_get_CellularClass(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_DeviceId(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_MessageClass(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_MessageType(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_SimIccId(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_Timestamp(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_ApplicationId(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ApplicationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_BinaryBody(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BinaryBody());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_ContentType(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_From(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_Headers(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SmsWapMessage_get_To(py::wrapper::Windows::Devices::Sms::SmsWapMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.To());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SmsWapMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::SmsWapMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SmsWapMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SmsWapMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SmsWapMessage[] = {
        { "cellular_class", reinterpret_cast<getter>(SmsWapMessage_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SmsWapMessage_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(SmsWapMessage_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(SmsWapMessage_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(SmsWapMessage_get_SimIccId), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(SmsWapMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "application_id", reinterpret_cast<getter>(SmsWapMessage_get_ApplicationId), nullptr, nullptr, nullptr },
        { "binary_body", reinterpret_cast<getter>(SmsWapMessage_get_BinaryBody), nullptr, nullptr, nullptr },
        { "content_type", reinterpret_cast<getter>(SmsWapMessage_get_ContentType), nullptr, nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(SmsWapMessage_get_From), nullptr, nullptr, nullptr },
        { "headers", reinterpret_cast<getter>(SmsWapMessage_get_Headers), nullptr, nullptr, nullptr },
        { "to", reinterpret_cast<getter>(SmsWapMessage_get_To), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsWapMessage[] = 
    {
        { Py_tp_new, _new_SmsWapMessage },
        { Py_tp_dealloc, _dealloc_SmsWapMessage },
        { Py_tp_methods, _methods_SmsWapMessage },
        { Py_tp_getset, _getset_SmsWapMessage },
        { },
    };

    static PyType_Spec _type_spec_SmsWapMessage =
    {
        "_winsdk_Windows_Devices_Sms.SmsWapMessage",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsWapMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsWapMessage
    };

    // ----- ISmsMessageBase interface --------------------
    constexpr const char* const _type_name_ISmsMessageBase = "ISmsMessageBase";

    static PyObject* _new_ISmsMessageBase(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ISmsMessageBase);
        return nullptr;
    }

    static void _dealloc_ISmsMessageBase(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ISmsMessageBase_get_CellularClass(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_DeviceId(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_MessageClass(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_MessageType(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISmsMessageBase_get_SimIccId(py::wrapper::Windows::Devices::Sms::ISmsMessageBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISmsMessageBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Sms::ISmsMessageBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISmsMessageBase[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ISmsMessageBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISmsMessageBase[] = {
        { "cellular_class", reinterpret_cast<getter>(ISmsMessageBase_get_CellularClass), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(ISmsMessageBase_get_DeviceId), nullptr, nullptr, nullptr },
        { "message_class", reinterpret_cast<getter>(ISmsMessageBase_get_MessageClass), nullptr, nullptr, nullptr },
        { "message_type", reinterpret_cast<getter>(ISmsMessageBase_get_MessageType), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(ISmsMessageBase_get_SimIccId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISmsMessageBase[] = 
    {
        { Py_tp_new, _new_ISmsMessageBase },
        { Py_tp_dealloc, _dealloc_ISmsMessageBase },
        { Py_tp_methods, _methods_ISmsMessageBase },
        { Py_tp_getset, _getset_ISmsMessageBase },
        { },
    };

    static PyType_Spec _type_spec_ISmsMessageBase =
    {
        "_winsdk_Windows_Devices_Sms.ISmsMessageBase",
        sizeof(py::wrapper::Windows::Devices::Sms::ISmsMessageBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISmsMessageBase
    };

    // ----- SmsEncodedLength struct --------------------
    constexpr const char* const _type_name_SmsEncodedLength = "SmsEncodedLength";

    PyObject* _new_SmsEncodedLength(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::Sms::SmsEncodedLength return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Devices::Sms::SmsEncodedLength>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _SegmentCount{};
        uint32_t _CharacterCountLastSegment{};
        uint32_t _CharactersPerSegment{};
        uint32_t _ByteCountLastSegment{};
        uint32_t _BytesPerSegment{};

        static const char* kwlist[] = {"segment_count", "character_count_last_segment", "characters_per_segment", "byte_count_last_segment", "bytes_per_segment", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIIII", const_cast<char**>(kwlist), &_SegmentCount, &_CharacterCountLastSegment, &_CharactersPerSegment, &_ByteCountLastSegment, &_BytesPerSegment))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::Sms::SmsEncodedLength return_value{ _SegmentCount, _CharacterCountLastSegment, _CharactersPerSegment, _ByteCountLastSegment, _BytesPerSegment };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_SmsEncodedLength(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self)
    {
    }

    static PyObject* SmsEncodedLength_get_SegmentCount(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SegmentCount);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_SegmentCount(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.SegmentCount = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsEncodedLength_get_CharacterCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharacterCountLastSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_CharacterCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.CharacterCountLastSegment = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsEncodedLength_get_CharactersPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CharactersPerSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_CharactersPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.CharactersPerSegment = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsEncodedLength_get_ByteCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ByteCountLastSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_ByteCountLastSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.ByteCountLastSegment = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SmsEncodedLength_get_BytesPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesPerSegment);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SmsEncodedLength_set_BytesPerSegment(py::wrapper::Windows::Devices::Sms::SmsEncodedLength* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.BytesPerSegment = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_SmsEncodedLength[] = {
        { "segment_count", reinterpret_cast<getter>(SmsEncodedLength_get_SegmentCount), reinterpret_cast<setter>(SmsEncodedLength_set_SegmentCount), nullptr, nullptr },
        { "character_count_last_segment", reinterpret_cast<getter>(SmsEncodedLength_get_CharacterCountLastSegment), reinterpret_cast<setter>(SmsEncodedLength_set_CharacterCountLastSegment), nullptr, nullptr },
        { "characters_per_segment", reinterpret_cast<getter>(SmsEncodedLength_get_CharactersPerSegment), reinterpret_cast<setter>(SmsEncodedLength_set_CharactersPerSegment), nullptr, nullptr },
        { "byte_count_last_segment", reinterpret_cast<getter>(SmsEncodedLength_get_ByteCountLastSegment), reinterpret_cast<setter>(SmsEncodedLength_set_ByteCountLastSegment), nullptr, nullptr },
        { "bytes_per_segment", reinterpret_cast<getter>(SmsEncodedLength_get_BytesPerSegment), reinterpret_cast<setter>(SmsEncodedLength_set_BytesPerSegment), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SmsEncodedLength[] = 
    {
        { Py_tp_new, _new_SmsEncodedLength },
        { Py_tp_dealloc, _dealloc_SmsEncodedLength },
        { Py_tp_getset, _getset_SmsEncodedLength },
        { },
    };

    static PyType_Spec _type_spec_SmsEncodedLength =
    {
        "_winsdk_Windows_Devices_Sms.SmsEncodedLength",
        sizeof(py::wrapper::Windows::Devices::Sms::SmsEncodedLength),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SmsEncodedLength
    };

    // ----- Windows.Devices.Sms Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Sms::SmsAppMessage>::python_type = py::register_python_type(module, _type_name_SmsAppMessage, &_type_spec_SmsAppMessage, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsBroadcastMessage>::python_type = py::register_python_type(module, _type_name_SmsBroadcastMessage, &_type_spec_SmsBroadcastMessage, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsDevice2>::python_type = py::register_python_type(module, _type_name_SmsDevice2, &_type_spec_SmsDevice2, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsFilterRule>::python_type = py::register_python_type(module, _type_name_SmsFilterRule, &_type_spec_SmsFilterRule, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsFilterRules>::python_type = py::register_python_type(module, _type_name_SmsFilterRules, &_type_spec_SmsFilterRules, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsMessageReceivedTriggerDetails>::python_type = py::register_python_type(module, _type_name_SmsMessageReceivedTriggerDetails, &_type_spec_SmsMessageReceivedTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsMessageRegistration>::python_type = py::register_python_type(module, _type_name_SmsMessageRegistration, &_type_spec_SmsMessageRegistration, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsSendMessageResult>::python_type = py::register_python_type(module, _type_name_SmsSendMessageResult, &_type_spec_SmsSendMessageResult, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsStatusMessage>::python_type = py::register_python_type(module, _type_name_SmsStatusMessage, &_type_spec_SmsStatusMessage, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsTextMessage2>::python_type = py::register_python_type(module, _type_name_SmsTextMessage2, &_type_spec_SmsTextMessage2, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsVoicemailMessage>::python_type = py::register_python_type(module, _type_name_SmsVoicemailMessage, &_type_spec_SmsVoicemailMessage, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsWapMessage>::python_type = py::register_python_type(module, _type_name_SmsWapMessage, &_type_spec_SmsWapMessage, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::ISmsMessageBase>::python_type = py::register_python_type(module, _type_name_ISmsMessageBase, &_type_spec_ISmsMessageBase, bases.get());
            py::winrt_type<winrt::Windows::Devices::Sms::SmsEncodedLength>::python_type = py::register_python_type(module, _type_name_SmsEncodedLength, &_type_spec_SmsEncodedLength, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Devices.Sms");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Sms",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Devices::Sms

PyMODINIT_FUNC
PyInit__winsdk_Windows_Devices_Sms (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Sms::module_def);
}
