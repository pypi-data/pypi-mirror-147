// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.4

#include "pybase.h"
#include "py.Windows.Security.Cryptography.Certificates.h"

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::Certificate>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateChain>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateExtension>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStores>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore>::python_type;

namespace py::cpp::Windows::Security::Cryptography::Certificates
{
    // ----- Certificate class --------------------
    constexpr const char* const _type_name_Certificate = "Certificate";

    static PyObject* _new_Certificate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Security::Cryptography::Certificates::Certificate instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Certificate(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Certificate_BuildChainAsync(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);

                return py::convert(self->obj.BuildChainAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>(args, 1);

                return py::convert(self->obj.BuildChainAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Certificate_GetCertificateBlob(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCertificateBlob());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Certificate_GetHashValue(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetHashValue());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetHashValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Certificate_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Certificate_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Certificate_get_EnhancedKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnhancedKeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_HasPrivateKey(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasPrivateKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_IsStronglyProtected(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStronglyProtected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_Issuer(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Issuer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SerialNumber(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SerialNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_Subject(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_ValidFrom(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ValidFrom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_ValidTo(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ValidTo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_IsSecurityDeviceBound(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSecurityDeviceBound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_KeyAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_KeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SignatureAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignatureAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SignatureHashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignatureHashAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_SubjectAlternativeName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubjectAlternativeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_IsPerUser(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPerUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyStorageProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Certificate_get_StoreName(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoreName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Certificate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::Certificate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Certificate[] = {
        { "build_chain_async", reinterpret_cast<PyCFunction>(Certificate_BuildChainAsync), METH_VARARGS, nullptr },
        { "get_certificate_blob", reinterpret_cast<PyCFunction>(Certificate_GetCertificateBlob), METH_VARARGS, nullptr },
        { "get_hash_value", reinterpret_cast<PyCFunction>(Certificate_GetHashValue), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Certificate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Certificate[] = {
        { "friendly_name", reinterpret_cast<getter>(Certificate_get_FriendlyName), reinterpret_cast<setter>(Certificate_put_FriendlyName), nullptr, nullptr },
        { "enhanced_key_usages", reinterpret_cast<getter>(Certificate_get_EnhancedKeyUsages), nullptr, nullptr, nullptr },
        { "has_private_key", reinterpret_cast<getter>(Certificate_get_HasPrivateKey), nullptr, nullptr, nullptr },
        { "is_strongly_protected", reinterpret_cast<getter>(Certificate_get_IsStronglyProtected), nullptr, nullptr, nullptr },
        { "issuer", reinterpret_cast<getter>(Certificate_get_Issuer), nullptr, nullptr, nullptr },
        { "serial_number", reinterpret_cast<getter>(Certificate_get_SerialNumber), nullptr, nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(Certificate_get_Subject), nullptr, nullptr, nullptr },
        { "valid_from", reinterpret_cast<getter>(Certificate_get_ValidFrom), nullptr, nullptr, nullptr },
        { "valid_to", reinterpret_cast<getter>(Certificate_get_ValidTo), nullptr, nullptr, nullptr },
        { "is_security_device_bound", reinterpret_cast<getter>(Certificate_get_IsSecurityDeviceBound), nullptr, nullptr, nullptr },
        { "key_algorithm_name", reinterpret_cast<getter>(Certificate_get_KeyAlgorithmName), nullptr, nullptr, nullptr },
        { "key_usages", reinterpret_cast<getter>(Certificate_get_KeyUsages), nullptr, nullptr, nullptr },
        { "signature_algorithm_name", reinterpret_cast<getter>(Certificate_get_SignatureAlgorithmName), nullptr, nullptr, nullptr },
        { "signature_hash_algorithm_name", reinterpret_cast<getter>(Certificate_get_SignatureHashAlgorithmName), nullptr, nullptr, nullptr },
        { "subject_alternative_name", reinterpret_cast<getter>(Certificate_get_SubjectAlternativeName), nullptr, nullptr, nullptr },
        { "is_per_user", reinterpret_cast<getter>(Certificate_get_IsPerUser), nullptr, nullptr, nullptr },
        { "key_storage_provider_name", reinterpret_cast<getter>(Certificate_get_KeyStorageProviderName), nullptr, nullptr, nullptr },
        { "store_name", reinterpret_cast<getter>(Certificate_get_StoreName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Certificate[] = 
    {
        { Py_tp_new, _new_Certificate },
        { Py_tp_dealloc, _dealloc_Certificate },
        { Py_tp_methods, _methods_Certificate },
        { Py_tp_getset, _getset_Certificate },
        { },
    };

    static PyType_Spec _type_spec_Certificate =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.Certificate",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::Certificate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Certificate
    };

    // ----- CertificateChain class --------------------
    constexpr const char* const _type_name_CertificateChain = "CertificateChain";

    static PyObject* _new_CertificateChain(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CertificateChain);
        return nullptr;
    }

    static void _dealloc_CertificateChain(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CertificateChain_GetCertificates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.GetCertificates(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateChain_Validate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Validate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>(args, 0);

                return py::convert(self->obj.Validate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_CertificateChain(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateChain>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateChain[] = {
        { "get_certificates", reinterpret_cast<PyCFunction>(CertificateChain_GetCertificates), METH_VARARGS, nullptr },
        { "validate", reinterpret_cast<PyCFunction>(CertificateChain_Validate), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateChain), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateChain[] = {
        { }
    };

    static PyType_Slot _type_slots_CertificateChain[] = 
    {
        { Py_tp_new, _new_CertificateChain },
        { Py_tp_dealloc, _dealloc_CertificateChain },
        { Py_tp_methods, _methods_CertificateChain },
        { Py_tp_getset, _getset_CertificateChain },
        { },
    };

    static PyType_Spec _type_spec_CertificateChain =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateChain",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateChain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateChain
    };

    // ----- CertificateEnrollmentManager class --------------------
    constexpr const char* const _type_name_CertificateEnrollmentManager = "CertificateEnrollmentManager";

    static PyObject* _new_CertificateEnrollmentManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CertificateEnrollmentManager);
        return nullptr;
    }

    static PyObject* CertificateEnrollmentManager_CreateRequestAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::CreateRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateEnrollmentManager_ImportPfxDataAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::ImportPfxDataAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::ImportPfxDataAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::ImportPfxDataAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateEnrollmentManager_InstallCertificateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::InstallCertificateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateEnrollmentManager_get_UserCertificateEnrollmentManager(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager::UserCertificateEnrollmentManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateEnrollmentManager[] = {
        { "create_request_async", reinterpret_cast<PyCFunction>(CertificateEnrollmentManager_CreateRequestAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "import_pfx_data_async", reinterpret_cast<PyCFunction>(CertificateEnrollmentManager_ImportPfxDataAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "install_certificate_async", reinterpret_cast<PyCFunction>(CertificateEnrollmentManager_InstallCertificateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_user_certificate_enrollment_manager", reinterpret_cast<PyCFunction>(CertificateEnrollmentManager_get_UserCertificateEnrollmentManager), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateEnrollmentManager[] = {
        { }
    };

    static PyType_Slot _type_slots_CertificateEnrollmentManager[] = 
    {
        { Py_tp_new, _new_CertificateEnrollmentManager },
        { Py_tp_methods, _methods_CertificateEnrollmentManager },
        { Py_tp_getset, _getset_CertificateEnrollmentManager },
        { },
    };

    static PyType_Spec _type_spec_CertificateEnrollmentManager =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateEnrollmentManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateEnrollmentManager
    };

    // ----- CertificateExtension class --------------------
    constexpr const char* const _type_name_CertificateExtension = "CertificateExtension";

    static PyObject* _new_CertificateExtension(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateExtension instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateExtension(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CertificateExtension_EncodeValue(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.EncodeValue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateExtension_get_Value(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateExtension_put_Value(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::array_view<uint8_t>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateExtension_get_ObjectId(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ObjectId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateExtension_put_ObjectId(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ObjectId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateExtension_get_IsCritical(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCritical());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateExtension_put_IsCritical(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCritical(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CertificateExtension(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateExtension>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateExtension[] = {
        { "encode_value", reinterpret_cast<PyCFunction>(CertificateExtension_EncodeValue), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateExtension), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateExtension[] = {
        { "value", reinterpret_cast<getter>(CertificateExtension_get_Value), reinterpret_cast<setter>(CertificateExtension_put_Value), nullptr, nullptr },
        { "object_id", reinterpret_cast<getter>(CertificateExtension_get_ObjectId), reinterpret_cast<setter>(CertificateExtension_put_ObjectId), nullptr, nullptr },
        { "is_critical", reinterpret_cast<getter>(CertificateExtension_get_IsCritical), reinterpret_cast<setter>(CertificateExtension_put_IsCritical), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateExtension[] = 
    {
        { Py_tp_new, _new_CertificateExtension },
        { Py_tp_dealloc, _dealloc_CertificateExtension },
        { Py_tp_methods, _methods_CertificateExtension },
        { Py_tp_getset, _getset_CertificateExtension },
        { },
    };

    static PyType_Spec _type_spec_CertificateExtension =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateExtension",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateExtension),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateExtension
    };

    // ----- CertificateKeyUsages class --------------------
    constexpr const char* const _type_name_CertificateKeyUsages = "CertificateKeyUsages";

    static PyObject* _new_CertificateKeyUsages(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CertificateKeyUsages_get_NonRepudiation(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NonRepudiation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_NonRepudiation(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NonRepudiation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_KeyEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyEncipherment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_KeyEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyEncipherment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_KeyCertificateSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyCertificateSign());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_KeyCertificateSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyCertificateSign(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_KeyAgreement(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyAgreement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_KeyAgreement(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyAgreement(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_EncipherOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncipherOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_EncipherOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EncipherOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_DigitalSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DigitalSignature());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_DigitalSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DigitalSignature(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_DataEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataEncipherment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_DataEncipherment(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DataEncipherment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateKeyUsages_get_CrlSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CrlSign());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateKeyUsages_put_CrlSign(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CrlSign(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CertificateKeyUsages(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateKeyUsages[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateKeyUsages), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateKeyUsages[] = {
        { "non_repudiation", reinterpret_cast<getter>(CertificateKeyUsages_get_NonRepudiation), reinterpret_cast<setter>(CertificateKeyUsages_put_NonRepudiation), nullptr, nullptr },
        { "key_encipherment", reinterpret_cast<getter>(CertificateKeyUsages_get_KeyEncipherment), reinterpret_cast<setter>(CertificateKeyUsages_put_KeyEncipherment), nullptr, nullptr },
        { "key_certificate_sign", reinterpret_cast<getter>(CertificateKeyUsages_get_KeyCertificateSign), reinterpret_cast<setter>(CertificateKeyUsages_put_KeyCertificateSign), nullptr, nullptr },
        { "key_agreement", reinterpret_cast<getter>(CertificateKeyUsages_get_KeyAgreement), reinterpret_cast<setter>(CertificateKeyUsages_put_KeyAgreement), nullptr, nullptr },
        { "encipher_only", reinterpret_cast<getter>(CertificateKeyUsages_get_EncipherOnly), reinterpret_cast<setter>(CertificateKeyUsages_put_EncipherOnly), nullptr, nullptr },
        { "digital_signature", reinterpret_cast<getter>(CertificateKeyUsages_get_DigitalSignature), reinterpret_cast<setter>(CertificateKeyUsages_put_DigitalSignature), nullptr, nullptr },
        { "data_encipherment", reinterpret_cast<getter>(CertificateKeyUsages_get_DataEncipherment), reinterpret_cast<setter>(CertificateKeyUsages_put_DataEncipherment), nullptr, nullptr },
        { "crl_sign", reinterpret_cast<getter>(CertificateKeyUsages_get_CrlSign), reinterpret_cast<setter>(CertificateKeyUsages_put_CrlSign), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateKeyUsages[] = 
    {
        { Py_tp_new, _new_CertificateKeyUsages },
        { Py_tp_dealloc, _dealloc_CertificateKeyUsages },
        { Py_tp_methods, _methods_CertificateKeyUsages },
        { Py_tp_getset, _getset_CertificateKeyUsages },
        { },
    };

    static PyType_Spec _type_spec_CertificateKeyUsages =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateKeyUsages",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateKeyUsages),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateKeyUsages
    };

    // ----- CertificateQuery class --------------------
    constexpr const char* const _type_name_CertificateQuery = "CertificateQuery";

    static PyObject* _new_CertificateQuery(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateQuery instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateQuery(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CertificateQuery_get_Thumbprint(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbprint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_Thumbprint(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::array_view<uint8_t>>(arg);

            self->obj.Thumbprint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_IssuerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IssuerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_IssuerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IssuerName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_HardwareOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_HardwareOnly(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.HardwareOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_EnhancedKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnhancedKeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateQuery_get_StoreName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoreName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_StoreName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.StoreName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_IncludeExpiredCertificates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncludeExpiredCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_IncludeExpiredCertificates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeExpiredCertificates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateQuery_get_IncludeDuplicates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncludeDuplicates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateQuery_put_IncludeDuplicates(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeDuplicates(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CertificateQuery(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateQuery[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateQuery), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateQuery[] = {
        { "thumbprint", reinterpret_cast<getter>(CertificateQuery_get_Thumbprint), reinterpret_cast<setter>(CertificateQuery_put_Thumbprint), nullptr, nullptr },
        { "issuer_name", reinterpret_cast<getter>(CertificateQuery_get_IssuerName), reinterpret_cast<setter>(CertificateQuery_put_IssuerName), nullptr, nullptr },
        { "hardware_only", reinterpret_cast<getter>(CertificateQuery_get_HardwareOnly), reinterpret_cast<setter>(CertificateQuery_put_HardwareOnly), nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(CertificateQuery_get_FriendlyName), reinterpret_cast<setter>(CertificateQuery_put_FriendlyName), nullptr, nullptr },
        { "enhanced_key_usages", reinterpret_cast<getter>(CertificateQuery_get_EnhancedKeyUsages), nullptr, nullptr, nullptr },
        { "store_name", reinterpret_cast<getter>(CertificateQuery_get_StoreName), reinterpret_cast<setter>(CertificateQuery_put_StoreName), nullptr, nullptr },
        { "include_expired_certificates", reinterpret_cast<getter>(CertificateQuery_get_IncludeExpiredCertificates), reinterpret_cast<setter>(CertificateQuery_put_IncludeExpiredCertificates), nullptr, nullptr },
        { "include_duplicates", reinterpret_cast<getter>(CertificateQuery_get_IncludeDuplicates), reinterpret_cast<setter>(CertificateQuery_put_IncludeDuplicates), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateQuery[] = 
    {
        { Py_tp_new, _new_CertificateQuery },
        { Py_tp_dealloc, _dealloc_CertificateQuery },
        { Py_tp_methods, _methods_CertificateQuery },
        { Py_tp_getset, _getset_CertificateQuery },
        { },
    };

    static PyType_Spec _type_spec_CertificateQuery =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateQuery",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateQuery),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateQuery
    };

    // ----- CertificateRequestProperties class --------------------
    constexpr const char* const _type_name_CertificateRequestProperties = "CertificateRequestProperties";

    static PyObject* _new_CertificateRequestProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CertificateRequestProperties(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CertificateRequestProperties_get_Subject(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_Subject(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::EnrollKeyUsages>(arg);

            self->obj.KeyUsages(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyStorageProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyStorageProviderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeySize(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeySize(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.KeySize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Exportable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(arg);

            self->obj.Exportable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(arg);

            self->obj.KeyProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_KeyAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_KeyAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyAlgorithmName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HashAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HashAlgorithmName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_AttestationCredentialCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttestationCredentialCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_AttestationCredentialCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.AttestationCredentialCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_SigningCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SigningCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_SigningCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.SigningCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_SmartcardReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SmartcardReaderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_SmartcardReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SmartcardReaderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_UseExistingKey(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UseExistingKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_UseExistingKey(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.UseExistingKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_CurveParameters(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurveParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_CurveParameters(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::array_view<uint8_t>>(arg);

            self->obj.CurveParameters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_CurveName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurveName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_CurveName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.CurveName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContainerNamePrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContainerNamePrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_ContainerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContainerName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CertificateRequestProperties_put_ContainerName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContainerName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CertificateRequestProperties_get_Extensions(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Extensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateRequestProperties_get_SubjectAlternativeName(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubjectAlternativeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateRequestProperties_get_SuppressedDefaults(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuppressedDefaults());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CertificateRequestProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateRequestProperties[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateRequestProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateRequestProperties[] = {
        { "subject", reinterpret_cast<getter>(CertificateRequestProperties_get_Subject), reinterpret_cast<setter>(CertificateRequestProperties_put_Subject), nullptr, nullptr },
        { "key_usages", reinterpret_cast<getter>(CertificateRequestProperties_get_KeyUsages), reinterpret_cast<setter>(CertificateRequestProperties_put_KeyUsages), nullptr, nullptr },
        { "key_storage_provider_name", reinterpret_cast<getter>(CertificateRequestProperties_get_KeyStorageProviderName), reinterpret_cast<setter>(CertificateRequestProperties_put_KeyStorageProviderName), nullptr, nullptr },
        { "key_size", reinterpret_cast<getter>(CertificateRequestProperties_get_KeySize), reinterpret_cast<setter>(CertificateRequestProperties_put_KeySize), nullptr, nullptr },
        { "exportable", reinterpret_cast<getter>(CertificateRequestProperties_get_Exportable), reinterpret_cast<setter>(CertificateRequestProperties_put_Exportable), nullptr, nullptr },
        { "key_protection_level", reinterpret_cast<getter>(CertificateRequestProperties_get_KeyProtectionLevel), reinterpret_cast<setter>(CertificateRequestProperties_put_KeyProtectionLevel), nullptr, nullptr },
        { "key_algorithm_name", reinterpret_cast<getter>(CertificateRequestProperties_get_KeyAlgorithmName), reinterpret_cast<setter>(CertificateRequestProperties_put_KeyAlgorithmName), nullptr, nullptr },
        { "hash_algorithm_name", reinterpret_cast<getter>(CertificateRequestProperties_get_HashAlgorithmName), reinterpret_cast<setter>(CertificateRequestProperties_put_HashAlgorithmName), nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(CertificateRequestProperties_get_FriendlyName), reinterpret_cast<setter>(CertificateRequestProperties_put_FriendlyName), nullptr, nullptr },
        { "attestation_credential_certificate", reinterpret_cast<getter>(CertificateRequestProperties_get_AttestationCredentialCertificate), reinterpret_cast<setter>(CertificateRequestProperties_put_AttestationCredentialCertificate), nullptr, nullptr },
        { "signing_certificate", reinterpret_cast<getter>(CertificateRequestProperties_get_SigningCertificate), reinterpret_cast<setter>(CertificateRequestProperties_put_SigningCertificate), nullptr, nullptr },
        { "smartcard_reader_name", reinterpret_cast<getter>(CertificateRequestProperties_get_SmartcardReaderName), reinterpret_cast<setter>(CertificateRequestProperties_put_SmartcardReaderName), nullptr, nullptr },
        { "use_existing_key", reinterpret_cast<getter>(CertificateRequestProperties_get_UseExistingKey), reinterpret_cast<setter>(CertificateRequestProperties_put_UseExistingKey), nullptr, nullptr },
        { "curve_parameters", reinterpret_cast<getter>(CertificateRequestProperties_get_CurveParameters), reinterpret_cast<setter>(CertificateRequestProperties_put_CurveParameters), nullptr, nullptr },
        { "curve_name", reinterpret_cast<getter>(CertificateRequestProperties_get_CurveName), reinterpret_cast<setter>(CertificateRequestProperties_put_CurveName), nullptr, nullptr },
        { "container_name_prefix", reinterpret_cast<getter>(CertificateRequestProperties_get_ContainerNamePrefix), reinterpret_cast<setter>(CertificateRequestProperties_put_ContainerNamePrefix), nullptr, nullptr },
        { "container_name", reinterpret_cast<getter>(CertificateRequestProperties_get_ContainerName), reinterpret_cast<setter>(CertificateRequestProperties_put_ContainerName), nullptr, nullptr },
        { "extensions", reinterpret_cast<getter>(CertificateRequestProperties_get_Extensions), nullptr, nullptr, nullptr },
        { "subject_alternative_name", reinterpret_cast<getter>(CertificateRequestProperties_get_SubjectAlternativeName), nullptr, nullptr, nullptr },
        { "suppressed_defaults", reinterpret_cast<getter>(CertificateRequestProperties_get_SuppressedDefaults), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateRequestProperties[] = 
    {
        { Py_tp_new, _new_CertificateRequestProperties },
        { Py_tp_dealloc, _dealloc_CertificateRequestProperties },
        { Py_tp_methods, _methods_CertificateRequestProperties },
        { Py_tp_getset, _getset_CertificateRequestProperties },
        { },
    };

    static PyType_Spec _type_spec_CertificateRequestProperties =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateRequestProperties",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateRequestProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateRequestProperties
    };

    // ----- CertificateStore class --------------------
    constexpr const char* const _type_name_CertificateStore = "CertificateStore";

    static PyObject* _new_CertificateStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CertificateStore);
        return nullptr;
    }

    static void _dealloc_CertificateStore(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CertificateStore_Add(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                self->obj.Add(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStore_Delete(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                self->obj.Delete(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStore_get_Name(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CertificateStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CertificateStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateStore[] = {
        { "add", reinterpret_cast<PyCFunction>(CertificateStore_Add), METH_VARARGS, nullptr },
        { "delete", reinterpret_cast<PyCFunction>(CertificateStore_Delete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CertificateStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateStore[] = {
        { "name", reinterpret_cast<getter>(CertificateStore_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CertificateStore[] = 
    {
        { Py_tp_new, _new_CertificateStore },
        { Py_tp_dealloc, _dealloc_CertificateStore },
        { Py_tp_methods, _methods_CertificateStore },
        { Py_tp_getset, _getset_CertificateStore },
        { },
    };

    static PyType_Spec _type_spec_CertificateStore =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateStore",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CertificateStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateStore
    };

    // ----- CertificateStores class --------------------
    constexpr const char* const _type_name_CertificateStores = "CertificateStores";

    static PyObject* _new_CertificateStores(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CertificateStores);
        return nullptr;
    }

    static PyObject* CertificateStores_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::FindAllAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStores_GetStoreByName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::GetStoreByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStores_GetUserStoreByName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::GetUserStoreByName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CertificateStores_get_IntermediateCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::IntermediateCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CertificateStores_get_TrustedRootCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::CertificateStores::TrustedRootCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CertificateStores[] = {
        { "find_all_async", reinterpret_cast<PyCFunction>(CertificateStores_FindAllAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_store_by_name", reinterpret_cast<PyCFunction>(CertificateStores_GetStoreByName), METH_VARARGS | METH_STATIC, nullptr },
        { "get_user_store_by_name", reinterpret_cast<PyCFunction>(CertificateStores_GetUserStoreByName), METH_VARARGS | METH_STATIC, nullptr },
        { "get_intermediate_certification_authorities", reinterpret_cast<PyCFunction>(CertificateStores_get_IntermediateCertificationAuthorities), METH_NOARGS | METH_STATIC, nullptr },
        { "get_trusted_root_certification_authorities", reinterpret_cast<PyCFunction>(CertificateStores_get_TrustedRootCertificationAuthorities), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CertificateStores[] = {
        { }
    };

    static PyType_Slot _type_slots_CertificateStores[] = 
    {
        { Py_tp_new, _new_CertificateStores },
        { Py_tp_methods, _methods_CertificateStores },
        { Py_tp_getset, _getset_CertificateStores },
        { },
    };

    static PyType_Spec _type_spec_CertificateStores =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CertificateStores",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CertificateStores
    };

    // ----- ChainBuildingParameters class --------------------
    constexpr const char* const _type_name_ChainBuildingParameters = "ChainBuildingParameters";

    static PyObject* _new_ChainBuildingParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChainBuildingParameters(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChainBuildingParameters_get_ValidationTimestamp(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ValidationTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_ValidationTimestamp(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.ValidationTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_RevocationCheckEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RevocationCheckEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_RevocationCheckEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RevocationCheckEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_NetworkRetrievalEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkRetrievalEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_NetworkRetrievalEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NetworkRetrievalEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_CurrentTimeValidationEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentTimeValidationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_CurrentTimeValidationEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CurrentTimeValidationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_AuthorityInformationAccessEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthorityInformationAccessEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainBuildingParameters_put_AuthorityInformationAccessEnabled(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AuthorityInformationAccessEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainBuildingParameters_get_EnhancedKeyUsages(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnhancedKeyUsages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChainBuildingParameters_get_ExclusiveTrustRoots(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExclusiveTrustRoots());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChainBuildingParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChainBuildingParameters[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChainBuildingParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChainBuildingParameters[] = {
        { "validation_timestamp", reinterpret_cast<getter>(ChainBuildingParameters_get_ValidationTimestamp), reinterpret_cast<setter>(ChainBuildingParameters_put_ValidationTimestamp), nullptr, nullptr },
        { "revocation_check_enabled", reinterpret_cast<getter>(ChainBuildingParameters_get_RevocationCheckEnabled), reinterpret_cast<setter>(ChainBuildingParameters_put_RevocationCheckEnabled), nullptr, nullptr },
        { "network_retrieval_enabled", reinterpret_cast<getter>(ChainBuildingParameters_get_NetworkRetrievalEnabled), reinterpret_cast<setter>(ChainBuildingParameters_put_NetworkRetrievalEnabled), nullptr, nullptr },
        { "current_time_validation_enabled", reinterpret_cast<getter>(ChainBuildingParameters_get_CurrentTimeValidationEnabled), reinterpret_cast<setter>(ChainBuildingParameters_put_CurrentTimeValidationEnabled), nullptr, nullptr },
        { "authority_information_access_enabled", reinterpret_cast<getter>(ChainBuildingParameters_get_AuthorityInformationAccessEnabled), reinterpret_cast<setter>(ChainBuildingParameters_put_AuthorityInformationAccessEnabled), nullptr, nullptr },
        { "enhanced_key_usages", reinterpret_cast<getter>(ChainBuildingParameters_get_EnhancedKeyUsages), nullptr, nullptr, nullptr },
        { "exclusive_trust_roots", reinterpret_cast<getter>(ChainBuildingParameters_get_ExclusiveTrustRoots), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChainBuildingParameters[] = 
    {
        { Py_tp_new, _new_ChainBuildingParameters },
        { Py_tp_dealloc, _dealloc_ChainBuildingParameters },
        { Py_tp_methods, _methods_ChainBuildingParameters },
        { Py_tp_getset, _getset_ChainBuildingParameters },
        { },
    };

    static PyType_Spec _type_spec_ChainBuildingParameters =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.ChainBuildingParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::ChainBuildingParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChainBuildingParameters
    };

    // ----- ChainValidationParameters class --------------------
    constexpr const char* const _type_name_ChainValidationParameters = "ChainValidationParameters";

    static PyObject* _new_ChainValidationParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChainValidationParameters(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChainValidationParameters_get_ServerDnsName(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerDnsName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainValidationParameters_put_ServerDnsName(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(arg);

            self->obj.ServerDnsName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChainValidationParameters_get_CertificateChainPolicy(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CertificateChainPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChainValidationParameters_put_CertificateChainPolicy(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateChainPolicy>(arg);

            self->obj.CertificateChainPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ChainValidationParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChainValidationParameters[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChainValidationParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChainValidationParameters[] = {
        { "server_dns_name", reinterpret_cast<getter>(ChainValidationParameters_get_ServerDnsName), reinterpret_cast<setter>(ChainValidationParameters_put_ServerDnsName), nullptr, nullptr },
        { "certificate_chain_policy", reinterpret_cast<getter>(ChainValidationParameters_get_CertificateChainPolicy), reinterpret_cast<setter>(ChainValidationParameters_put_CertificateChainPolicy), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChainValidationParameters[] = 
    {
        { Py_tp_new, _new_ChainValidationParameters },
        { Py_tp_dealloc, _dealloc_ChainValidationParameters },
        { Py_tp_methods, _methods_ChainValidationParameters },
        { Py_tp_getset, _getset_ChainValidationParameters },
        { },
    };

    static PyType_Spec _type_spec_ChainValidationParameters =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.ChainValidationParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::ChainValidationParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChainValidationParameters
    };

    // ----- CmsAttachedSignature class --------------------
    constexpr const char* const _type_name_CmsAttachedSignature = "CmsAttachedSignature";

    static PyObject* _new_CmsAttachedSignature(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CmsAttachedSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CmsAttachedSignature_GenerateSignatureAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature::GenerateSignatureAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_VerifySignature(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.VerifySignature());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_get_Certificates(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_get_Content(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsAttachedSignature_get_Signers(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Signers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CmsAttachedSignature(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsAttachedSignature[] = {
        { "generate_signature_async", reinterpret_cast<PyCFunction>(CmsAttachedSignature_GenerateSignatureAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "verify_signature", reinterpret_cast<PyCFunction>(CmsAttachedSignature_VerifySignature), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CmsAttachedSignature), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CmsAttachedSignature[] = {
        { "certificates", reinterpret_cast<getter>(CmsAttachedSignature_get_Certificates), nullptr, nullptr, nullptr },
        { "content", reinterpret_cast<getter>(CmsAttachedSignature_get_Content), nullptr, nullptr, nullptr },
        { "signers", reinterpret_cast<getter>(CmsAttachedSignature_get_Signers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CmsAttachedSignature[] = 
    {
        { Py_tp_new, _new_CmsAttachedSignature },
        { Py_tp_dealloc, _dealloc_CmsAttachedSignature },
        { Py_tp_methods, _methods_CmsAttachedSignature },
        { Py_tp_getset, _getset_CmsAttachedSignature },
        { },
    };

    static PyType_Spec _type_spec_CmsAttachedSignature =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CmsAttachedSignature",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsAttachedSignature),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsAttachedSignature
    };

    // ----- CmsDetachedSignature class --------------------
    constexpr const char* const _type_name_CmsDetachedSignature = "CmsDetachedSignature";

    static PyObject* _new_CmsDetachedSignature(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CmsDetachedSignature(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CmsDetachedSignature_GenerateSignatureAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Security::Cryptography::Certificates::Certificate>>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature::GenerateSignatureAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsDetachedSignature_VerifySignatureAsync(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.VerifySignatureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CmsDetachedSignature_get_Certificates(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsDetachedSignature_get_Signers(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Signers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CmsDetachedSignature(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsDetachedSignature[] = {
        { "generate_signature_async", reinterpret_cast<PyCFunction>(CmsDetachedSignature_GenerateSignatureAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "verify_signature_async", reinterpret_cast<PyCFunction>(CmsDetachedSignature_VerifySignatureAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CmsDetachedSignature), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CmsDetachedSignature[] = {
        { "certificates", reinterpret_cast<getter>(CmsDetachedSignature_get_Certificates), nullptr, nullptr, nullptr },
        { "signers", reinterpret_cast<getter>(CmsDetachedSignature_get_Signers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CmsDetachedSignature[] = 
    {
        { Py_tp_new, _new_CmsDetachedSignature },
        { Py_tp_dealloc, _dealloc_CmsDetachedSignature },
        { Py_tp_methods, _methods_CmsDetachedSignature },
        { Py_tp_getset, _getset_CmsDetachedSignature },
        { },
    };

    static PyType_Spec _type_spec_CmsDetachedSignature =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CmsDetachedSignature",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsDetachedSignature),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsDetachedSignature
    };

    // ----- CmsSignerInfo class --------------------
    constexpr const char* const _type_name_CmsSignerInfo = "CmsSignerInfo";

    static PyObject* _new_CmsSignerInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CmsSignerInfo(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CmsSignerInfo_get_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HashAlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CmsSignerInfo_put_HashAlgorithmName(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.HashAlgorithmName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CmsSignerInfo_get_Certificate(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Certificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CmsSignerInfo_put_Certificate(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.Certificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CmsSignerInfo_get_TimestampInfo(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimestampInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CmsSignerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsSignerInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CmsSignerInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CmsSignerInfo[] = {
        { "hash_algorithm_name", reinterpret_cast<getter>(CmsSignerInfo_get_HashAlgorithmName), reinterpret_cast<setter>(CmsSignerInfo_put_HashAlgorithmName), nullptr, nullptr },
        { "certificate", reinterpret_cast<getter>(CmsSignerInfo_get_Certificate), reinterpret_cast<setter>(CmsSignerInfo_put_Certificate), nullptr, nullptr },
        { "timestamp_info", reinterpret_cast<getter>(CmsSignerInfo_get_TimestampInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CmsSignerInfo[] = 
    {
        { Py_tp_new, _new_CmsSignerInfo },
        { Py_tp_dealloc, _dealloc_CmsSignerInfo },
        { Py_tp_methods, _methods_CmsSignerInfo },
        { Py_tp_getset, _getset_CmsSignerInfo },
        { },
    };

    static PyType_Spec _type_spec_CmsSignerInfo =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CmsSignerInfo",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsSignerInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsSignerInfo
    };

    // ----- CmsTimestampInfo class --------------------
    constexpr const char* const _type_name_CmsTimestampInfo = "CmsTimestampInfo";

    static PyObject* _new_CmsTimestampInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CmsTimestampInfo);
        return nullptr;
    }

    static void _dealloc_CmsTimestampInfo(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CmsTimestampInfo_get_Certificates(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Certificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsTimestampInfo_get_SigningCertificate(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SigningCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CmsTimestampInfo_get_Timestamp(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CmsTimestampInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CmsTimestampInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CmsTimestampInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CmsTimestampInfo[] = {
        { "certificates", reinterpret_cast<getter>(CmsTimestampInfo_get_Certificates), nullptr, nullptr, nullptr },
        { "signing_certificate", reinterpret_cast<getter>(CmsTimestampInfo_get_SigningCertificate), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(CmsTimestampInfo_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CmsTimestampInfo[] = 
    {
        { Py_tp_new, _new_CmsTimestampInfo },
        { Py_tp_dealloc, _dealloc_CmsTimestampInfo },
        { Py_tp_methods, _methods_CmsTimestampInfo },
        { Py_tp_getset, _getset_CmsTimestampInfo },
        { },
    };

    static PyType_Spec _type_spec_CmsTimestampInfo =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.CmsTimestampInfo",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::CmsTimestampInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CmsTimestampInfo
    };

    // ----- KeyAlgorithmNames class --------------------
    constexpr const char* const _type_name_KeyAlgorithmNames = "KeyAlgorithmNames";

    static PyObject* _new_KeyAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyAlgorithmNames);
        return nullptr;
    }

    static PyObject* KeyAlgorithmNames_get_Dsa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Dsa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh521(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh521());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa521(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa521());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Rsa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Rsa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdh(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyAlgorithmNames_get_Ecdsa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames::Ecdsa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyAlgorithmNames[] = {
        { "get_dsa", reinterpret_cast<PyCFunction>(KeyAlgorithmNames_get_Dsa), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdh256", reinterpret_cast<PyCFunction>(KeyAlgorithmNames_get_Ecdh256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdh384", reinterpret_cast<PyCFunction>(KeyAlgorithmNames_get_Ecdh384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdh521", reinterpret_cast<PyCFunction>(KeyAlgorithmNames_get_Ecdh521), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa256", reinterpret_cast<PyCFunction>(KeyAlgorithmNames_get_Ecdsa256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa384", reinterpret_cast<PyCFunction>(KeyAlgorithmNames_get_Ecdsa384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa521", reinterpret_cast<PyCFunction>(KeyAlgorithmNames_get_Ecdsa521), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa", reinterpret_cast<PyCFunction>(KeyAlgorithmNames_get_Rsa), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdh", reinterpret_cast<PyCFunction>(KeyAlgorithmNames_get_Ecdh), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa", reinterpret_cast<PyCFunction>(KeyAlgorithmNames_get_Ecdsa), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_KeyAlgorithmNames[] = 
    {
        { Py_tp_new, _new_KeyAlgorithmNames },
        { Py_tp_methods, _methods_KeyAlgorithmNames },
        { Py_tp_getset, _getset_KeyAlgorithmNames },
        { },
    };

    static PyType_Spec _type_spec_KeyAlgorithmNames =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.KeyAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyAlgorithmNames
    };

    // ----- KeyAttestationHelper class --------------------
    constexpr const char* const _type_name_KeyAttestationHelper = "KeyAttestationHelper";

    static PyObject* _new_KeyAttestationHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyAttestationHelper);
        return nullptr;
    }

    static PyObject* KeyAttestationHelper_DecryptTpmAttestationCredentialAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper::DecryptTpmAttestationCredentialAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper::DecryptTpmAttestationCredentialAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyAttestationHelper_GetTpmAttestationCredentialId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper::GetTpmAttestationCredentialId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyAttestationHelper[] = {
        { "decrypt_tpm_attestation_credential_async", reinterpret_cast<PyCFunction>(KeyAttestationHelper_DecryptTpmAttestationCredentialAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_tpm_attestation_credential_id", reinterpret_cast<PyCFunction>(KeyAttestationHelper_GetTpmAttestationCredentialId), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyAttestationHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_KeyAttestationHelper[] = 
    {
        { Py_tp_new, _new_KeyAttestationHelper },
        { Py_tp_methods, _methods_KeyAttestationHelper },
        { Py_tp_getset, _getset_KeyAttestationHelper },
        { },
    };

    static PyType_Spec _type_spec_KeyAttestationHelper =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.KeyAttestationHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyAttestationHelper
    };

    // ----- KeyStorageProviderNames class --------------------
    constexpr const char* const _type_name_KeyStorageProviderNames = "KeyStorageProviderNames";

    static PyObject* _new_KeyStorageProviderNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_KeyStorageProviderNames);
        return nullptr;
    }

    static PyObject* KeyStorageProviderNames_get_PlatformKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::PlatformKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyStorageProviderNames_get_SmartcardKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::SmartcardKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyStorageProviderNames_get_SoftwareKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::SoftwareKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyStorageProviderNames_get_PassportKeyStorageProvider(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames::PassportKeyStorageProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyStorageProviderNames[] = {
        { "get_platform_key_storage_provider", reinterpret_cast<PyCFunction>(KeyStorageProviderNames_get_PlatformKeyStorageProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "get_smartcard_key_storage_provider", reinterpret_cast<PyCFunction>(KeyStorageProviderNames_get_SmartcardKeyStorageProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "get_software_key_storage_provider", reinterpret_cast<PyCFunction>(KeyStorageProviderNames_get_SoftwareKeyStorageProvider), METH_NOARGS | METH_STATIC, nullptr },
        { "get_passport_key_storage_provider", reinterpret_cast<PyCFunction>(KeyStorageProviderNames_get_PassportKeyStorageProvider), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyStorageProviderNames[] = {
        { }
    };

    static PyType_Slot _type_slots_KeyStorageProviderNames[] = 
    {
        { Py_tp_new, _new_KeyStorageProviderNames },
        { Py_tp_methods, _methods_KeyStorageProviderNames },
        { Py_tp_getset, _getset_KeyStorageProviderNames },
        { },
    };

    static PyType_Spec _type_spec_KeyStorageProviderNames =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.KeyStorageProviderNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyStorageProviderNames
    };

    // ----- PfxImportParameters class --------------------
    constexpr const char* const _type_name_PfxImportParameters = "PfxImportParameters";

    static PyObject* _new_PfxImportParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PfxImportParameters(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PfxImportParameters_get_ReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReaderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_ReaderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ReaderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyStorageProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_KeyStorageProviderName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.KeyStorageProviderName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_KeyProtectionLevel(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(arg);

            self->obj.KeyProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_InstallOptions(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_InstallOptions(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(arg);

            self->obj.InstallOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_FriendlyName(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Exportable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_Exportable(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(arg);

            self->obj.Exportable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PfxImportParameters_get_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContainerNamePrefix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PfxImportParameters_put_ContainerNamePrefix(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContainerNamePrefix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_PfxImportParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PfxImportParameters[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PfxImportParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PfxImportParameters[] = {
        { "reader_name", reinterpret_cast<getter>(PfxImportParameters_get_ReaderName), reinterpret_cast<setter>(PfxImportParameters_put_ReaderName), nullptr, nullptr },
        { "key_storage_provider_name", reinterpret_cast<getter>(PfxImportParameters_get_KeyStorageProviderName), reinterpret_cast<setter>(PfxImportParameters_put_KeyStorageProviderName), nullptr, nullptr },
        { "key_protection_level", reinterpret_cast<getter>(PfxImportParameters_get_KeyProtectionLevel), reinterpret_cast<setter>(PfxImportParameters_put_KeyProtectionLevel), nullptr, nullptr },
        { "install_options", reinterpret_cast<getter>(PfxImportParameters_get_InstallOptions), reinterpret_cast<setter>(PfxImportParameters_put_InstallOptions), nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(PfxImportParameters_get_FriendlyName), reinterpret_cast<setter>(PfxImportParameters_put_FriendlyName), nullptr, nullptr },
        { "exportable", reinterpret_cast<getter>(PfxImportParameters_get_Exportable), reinterpret_cast<setter>(PfxImportParameters_put_Exportable), nullptr, nullptr },
        { "container_name_prefix", reinterpret_cast<getter>(PfxImportParameters_get_ContainerNamePrefix), reinterpret_cast<setter>(PfxImportParameters_put_ContainerNamePrefix), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PfxImportParameters[] = 
    {
        { Py_tp_new, _new_PfxImportParameters },
        { Py_tp_dealloc, _dealloc_PfxImportParameters },
        { Py_tp_methods, _methods_PfxImportParameters },
        { Py_tp_getset, _getset_PfxImportParameters },
        { },
    };

    static PyType_Spec _type_spec_PfxImportParameters =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.PfxImportParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::PfxImportParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PfxImportParameters
    };

    // ----- StandardCertificateStoreNames class --------------------
    constexpr const char* const _type_name_StandardCertificateStoreNames = "StandardCertificateStoreNames";

    static PyObject* _new_StandardCertificateStoreNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StandardCertificateStoreNames);
        return nullptr;
    }

    static PyObject* StandardCertificateStoreNames_get_IntermediateCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames::IntermediateCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardCertificateStoreNames_get_Personal(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames::Personal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardCertificateStoreNames_get_TrustedRootCertificationAuthorities(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames::TrustedRootCertificationAuthorities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StandardCertificateStoreNames[] = {
        { "get_intermediate_certification_authorities", reinterpret_cast<PyCFunction>(StandardCertificateStoreNames_get_IntermediateCertificationAuthorities), METH_NOARGS | METH_STATIC, nullptr },
        { "get_personal", reinterpret_cast<PyCFunction>(StandardCertificateStoreNames_get_Personal), METH_NOARGS | METH_STATIC, nullptr },
        { "get_trusted_root_certification_authorities", reinterpret_cast<PyCFunction>(StandardCertificateStoreNames_get_TrustedRootCertificationAuthorities), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StandardCertificateStoreNames[] = {
        { }
    };

    static PyType_Slot _type_slots_StandardCertificateStoreNames[] = 
    {
        { Py_tp_new, _new_StandardCertificateStoreNames },
        { Py_tp_methods, _methods_StandardCertificateStoreNames },
        { Py_tp_getset, _getset_StandardCertificateStoreNames },
        { },
    };

    static PyType_Spec _type_spec_StandardCertificateStoreNames =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.StandardCertificateStoreNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StandardCertificateStoreNames
    };

    // ----- SubjectAlternativeNameInfo class --------------------
    constexpr const char* const _type_name_SubjectAlternativeNameInfo = "SubjectAlternativeNameInfo";

    static PyObject* _new_SubjectAlternativeNameInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SubjectAlternativeNameInfo(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SubjectAlternativeNameInfo_get_DistinguishedName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DistinguishedName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_DnsName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DnsName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_EmailName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EmailName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_IPAddress(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IPAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_PrincipalName(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrincipalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_Url(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Url());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_DistinguishedNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DistinguishedNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_DnsNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DnsNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_EmailNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EmailNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_Extension(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Extension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_IPAddresses(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IPAddresses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_PrincipalNames(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrincipalNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SubjectAlternativeNameInfo_get_Urls(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Urls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SubjectAlternativeNameInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SubjectAlternativeNameInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SubjectAlternativeNameInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SubjectAlternativeNameInfo[] = {
        { "distinguished_name", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_DistinguishedName), nullptr, nullptr, nullptr },
        { "dns_name", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_DnsName), nullptr, nullptr, nullptr },
        { "email_name", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_EmailName), nullptr, nullptr, nullptr },
        { "ip_address", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_IPAddress), nullptr, nullptr, nullptr },
        { "principal_name", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_PrincipalName), nullptr, nullptr, nullptr },
        { "url", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_Url), nullptr, nullptr, nullptr },
        { "distinguished_names", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_DistinguishedNames), nullptr, nullptr, nullptr },
        { "dns_names", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_DnsNames), nullptr, nullptr, nullptr },
        { "email_names", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_EmailNames), nullptr, nullptr, nullptr },
        { "extension", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_Extension), nullptr, nullptr, nullptr },
        { "ip_addresses", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_IPAddresses), nullptr, nullptr, nullptr },
        { "principal_names", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_PrincipalNames), nullptr, nullptr, nullptr },
        { "urls", reinterpret_cast<getter>(SubjectAlternativeNameInfo_get_Urls), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SubjectAlternativeNameInfo[] = 
    {
        { Py_tp_new, _new_SubjectAlternativeNameInfo },
        { Py_tp_dealloc, _dealloc_SubjectAlternativeNameInfo },
        { Py_tp_methods, _methods_SubjectAlternativeNameInfo },
        { Py_tp_getset, _getset_SubjectAlternativeNameInfo },
        { },
    };

    static PyType_Spec _type_spec_SubjectAlternativeNameInfo =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.SubjectAlternativeNameInfo",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SubjectAlternativeNameInfo
    };

    // ----- UserCertificateEnrollmentManager class --------------------
    constexpr const char* const _type_name_UserCertificateEnrollmentManager = "UserCertificateEnrollmentManager";

    static PyObject* _new_UserCertificateEnrollmentManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserCertificateEnrollmentManager);
        return nullptr;
    }

    static void _dealloc_UserCertificateEnrollmentManager(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserCertificateEnrollmentManager_CreateRequestAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>(args, 0);

                return py::convert(self->obj.CreateRequestAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateEnrollmentManager_ImportPfxDataAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>(args, 2);

                return py::convert(self->obj.ImportPfxDataAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);

                return py::convert(self->obj.ImportPfxDataAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::ExportOption>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::KeyProtectionLevel>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 4);
                auto param5 = py::convert_to<winrt::hstring>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);

                return py::convert(self->obj.ImportPfxDataAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateEnrollmentManager_InstallCertificateAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::InstallOptions>(args, 1);

                return py::convert(self->obj.InstallCertificateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_UserCertificateEnrollmentManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserCertificateEnrollmentManager[] = {
        { "create_request_async", reinterpret_cast<PyCFunction>(UserCertificateEnrollmentManager_CreateRequestAsync), METH_VARARGS, nullptr },
        { "import_pfx_data_async", reinterpret_cast<PyCFunction>(UserCertificateEnrollmentManager_ImportPfxDataAsync), METH_VARARGS, nullptr },
        { "install_certificate_async", reinterpret_cast<PyCFunction>(UserCertificateEnrollmentManager_InstallCertificateAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserCertificateEnrollmentManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserCertificateEnrollmentManager[] = {
        { }
    };

    static PyType_Slot _type_slots_UserCertificateEnrollmentManager[] = 
    {
        { Py_tp_new, _new_UserCertificateEnrollmentManager },
        { Py_tp_dealloc, _dealloc_UserCertificateEnrollmentManager },
        { Py_tp_methods, _methods_UserCertificateEnrollmentManager },
        { Py_tp_getset, _getset_UserCertificateEnrollmentManager },
        { },
    };

    static PyType_Spec _type_spec_UserCertificateEnrollmentManager =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.UserCertificateEnrollmentManager",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserCertificateEnrollmentManager
    };

    // ----- UserCertificateStore class --------------------
    constexpr const char* const _type_name_UserCertificateStore = "UserCertificateStore";

    static PyObject* _new_UserCertificateStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UserCertificateStore);
        return nullptr;
    }

    static void _dealloc_UserCertificateStore(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UserCertificateStore_RequestAddAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                return py::convert(self->obj.RequestAddAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateStore_RequestDeleteAsync(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);

                return py::convert(self->obj.RequestDeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UserCertificateStore_get_Name(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UserCertificateStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserCertificateStore[] = {
        { "request_add_async", reinterpret_cast<PyCFunction>(UserCertificateStore_RequestAddAsync), METH_VARARGS, nullptr },
        { "request_delete_async", reinterpret_cast<PyCFunction>(UserCertificateStore_RequestDeleteAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UserCertificateStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserCertificateStore[] = {
        { "name", reinterpret_cast<getter>(UserCertificateStore_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserCertificateStore[] = 
    {
        { Py_tp_new, _new_UserCertificateStore },
        { Py_tp_dealloc, _dealloc_UserCertificateStore },
        { Py_tp_methods, _methods_UserCertificateStore },
        { Py_tp_getset, _getset_UserCertificateStore },
        { },
    };

    static PyType_Spec _type_spec_UserCertificateStore =
    {
        "_winsdk_Windows_Security_Cryptography_Certificates.UserCertificateStore",
        sizeof(py::wrapper::Windows::Security::Cryptography::Certificates::UserCertificateStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserCertificateStore
    };

    // ----- Windows.Security.Cryptography.Certificates Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::Certificate>::python_type = py::register_python_type(module, _type_name_Certificate, &_type_spec_Certificate, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateChain>::python_type = py::register_python_type(module, _type_name_CertificateChain, &_type_spec_CertificateChain, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateEnrollmentManager>::python_type = py::register_python_type(module, _type_name_CertificateEnrollmentManager, &_type_spec_CertificateEnrollmentManager, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateExtension>::python_type = py::register_python_type(module, _type_name_CertificateExtension, &_type_spec_CertificateExtension, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateKeyUsages>::python_type = py::register_python_type(module, _type_name_CertificateKeyUsages, &_type_spec_CertificateKeyUsages, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateQuery>::python_type = py::register_python_type(module, _type_name_CertificateQuery, &_type_spec_CertificateQuery, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateRequestProperties>::python_type = py::register_python_type(module, _type_name_CertificateRequestProperties, &_type_spec_CertificateRequestProperties, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStore>::python_type = py::register_python_type(module, _type_name_CertificateStore, &_type_spec_CertificateStore, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CertificateStores>::python_type = py::register_python_type(module, _type_name_CertificateStores, &_type_spec_CertificateStores, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::ChainBuildingParameters>::python_type = py::register_python_type(module, _type_name_ChainBuildingParameters, &_type_spec_ChainBuildingParameters, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::ChainValidationParameters>::python_type = py::register_python_type(module, _type_name_ChainValidationParameters, &_type_spec_ChainValidationParameters, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsAttachedSignature>::python_type = py::register_python_type(module, _type_name_CmsAttachedSignature, &_type_spec_CmsAttachedSignature, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsDetachedSignature>::python_type = py::register_python_type(module, _type_name_CmsDetachedSignature, &_type_spec_CmsDetachedSignature, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsSignerInfo>::python_type = py::register_python_type(module, _type_name_CmsSignerInfo, &_type_spec_CmsSignerInfo, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::CmsTimestampInfo>::python_type = py::register_python_type(module, _type_name_CmsTimestampInfo, &_type_spec_CmsTimestampInfo, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyAlgorithmNames>::python_type = py::register_python_type(module, _type_name_KeyAlgorithmNames, &_type_spec_KeyAlgorithmNames, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyAttestationHelper>::python_type = py::register_python_type(module, _type_name_KeyAttestationHelper, &_type_spec_KeyAttestationHelper, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::KeyStorageProviderNames>::python_type = py::register_python_type(module, _type_name_KeyStorageProviderNames, &_type_spec_KeyStorageProviderNames, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::PfxImportParameters>::python_type = py::register_python_type(module, _type_name_PfxImportParameters, &_type_spec_PfxImportParameters, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::StandardCertificateStoreNames>::python_type = py::register_python_type(module, _type_name_StandardCertificateStoreNames, &_type_spec_StandardCertificateStoreNames, nullptr);
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::SubjectAlternativeNameInfo>::python_type = py::register_python_type(module, _type_name_SubjectAlternativeNameInfo, &_type_spec_SubjectAlternativeNameInfo, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateEnrollmentManager>::python_type = py::register_python_type(module, _type_name_UserCertificateEnrollmentManager, &_type_spec_UserCertificateEnrollmentManager, bases.get());
            py::winrt_type<winrt::Windows::Security::Cryptography::Certificates::UserCertificateStore>::python_type = py::register_python_type(module, _type_name_UserCertificateStore, &_type_spec_UserCertificateStore, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Security.Cryptography.Certificates");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Security_Cryptography_Certificates",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Security::Cryptography::Certificates

PyMODINIT_FUNC
PyInit__winsdk_Windows_Security_Cryptography_Certificates (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Security::Cryptography::Certificates::module_def);
}
